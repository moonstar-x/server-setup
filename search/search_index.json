{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This is a guide that focuses on the installation and configuration process of my self-hosted infrastructure that runs some custom services that I use.</p> <p>As you'll notice, this setup is actually composed of multiple servers with specific roles, all of which use Docker exclusively.</p> <p>Currently, these are the servers available:</p> <ul> <li>deploy-us-east-1</li> <li>dev-ec-uio-1</li> <li>dev-eu-west-1</li> <li>misc-ec-uio-1</li> <li>misc-us-east-1</li> </ul>"},{"location":"servers/deploy-us-east-1/configuration/","title":"Introduction","text":"<p>This section contains details of the <code>deploy-us-east-1</code> server.</p> <p>This server is mostly used for deployment purposes.</p>"},{"location":"servers/deploy-us-east-1/configuration/#server-specs","title":"Server Specs","text":"<p>This server is a Hetzner CPX-11 VPS with the following specs:</p> <ul> <li>OS: Ubuntu Server 22.04 LTS 64-bit</li> <li>CPU: 2 vCPU</li> <li>RAM: 2GB</li> <li>Storage: 40GB</li> </ul>"},{"location":"servers/deploy-us-east-1/configuration/custom-scripts/","title":"Custom Scripts","text":"<p>We will create some custom scripts that will help us with certain tasks. For this, we'll create the following folder:</p> <pre><code>mkdir -p /usr/local/bin\n</code></pre> <p>Then inside this folder we'll insert all the scripts that we'll add here. Make sure to make them executable with:</p> <pre><code>chmod +x &lt;file&gt;\n</code></pre>"},{"location":"servers/deploy-us-east-1/configuration/custom-scripts/#custom-docker-update","title":"<code>custom-docker-update</code>","text":"<p>We'll use this script to manually update docker compose containers.</p> <p>Usage</p> <p>Run <code>custom-docker-update</code> inside the folder where <code>docker-compose.yml</code> is located to update the container images used.</p> <pre><code>#!/bin/bash\n\necho \"Stopping containers...\"\ndocker compose stop\n\necho \"Removing containers...\"\ndocker compose rm -f\n\necho \"Pulling images...\"\ndocker compose pull\n\necho \"Restarting containers...\"\ndocker compose up -d\n</code></pre>"},{"location":"servers/deploy-us-east-1/configuration/custom-scripts/#custom-docker-restart","title":"<code>custom-docker-restart</code>","text":"<p>We'll use this script to completely restart docker compose containers, this removes the containers and restarts them.</p> <p>Usage</p> <p>Run <code>custom-docker-restart</code> inside the folder where <code>docker-compose.yml</code> is located to update the container images used.</p> <pre><code>#!/bin/bash\n\ndocker compose rm -fs &amp;&amp; docker compose up -d\n</code></pre>"},{"location":"servers/deploy-us-east-1/configuration/docker/","title":"Docker","text":"<p>All the services in the server will be run through Docker. We'll need to install it first.</p>"},{"location":"servers/deploy-us-east-1/configuration/docker/#installation","title":"Installation","text":"<p>To install Docker, simply run the following commands:</p> <pre><code>curl -fsSL https://get.docker.com -o get-docker.sh\nsudo sh ./get-docker.sh\n</code></pre> <p>Once it's done, you can remove the downloaded script:</p> <pre><code>rm get-docker.sh\n</code></pre>"},{"location":"servers/deploy-us-east-1/configuration/docker/#permissions","title":"Permissions","text":"<p>We'll add the required permissions for our user into the <code>docker</code> group.</p> <pre><code>sudo groupadd docker\nsudo gpasswd -a $USER docker\n</code></pre>"},{"location":"servers/deploy-us-east-1/configuration/installation/","title":"Installation","text":"<p>Since the VPS comes with the OS already installed, nothing else must be done.</p>"},{"location":"servers/deploy-us-east-1/configuration/installation/#post-installation","title":"Post-Installation","text":"<p>As a general rule of thumb, after installing the OS it is recommended to update the sources and packages:</p> <pre><code>sudo apt-get update &amp;&amp; sudo apt-get upgrade\n</code></pre>"},{"location":"servers/deploy-us-east-1/configuration/installation/#configuring-date-and-time","title":"Configuring Date and Time","text":"<p>By default, the OS will be installed with GMT+0 as the timezone. We'll change this to conform with our real timezone which is GMT-5.</p> <pre><code>sudo timedatectl set-timezone America/Guayaquil\n</code></pre>"},{"location":"servers/deploy-us-east-1/configuration/installation/#packages","title":"Packages","text":"<p>Here's a list of packages I like to have on the server.</p> <pre><code>sudo apt-get install openssh-server openssh-client net-tools neofetch nload progress nano htop git\n</code></pre>"},{"location":"servers/deploy-us-east-1/configuration/installation/#firewall","title":"Firewall","text":"<p>Hetzner comes with a free Firewall service that I recommend you use to only allow certain ports on certain interfaces.</p> <p>I won't go much into detail because the rules depend heavily on your use case, though I recommend you be as restrictive as possible when defining ports and interfaces.</p>"},{"location":"servers/deploy-us-east-1/configuration/installation/#git","title":"Git","text":"<p>By default, <code>git</code> does not have a credential store configured, so make sure you run the following command to allow git operations in protected repos:</p> <pre><code>git config --global credential.helper store\n</code></pre>"},{"location":"servers/deploy-us-east-1/deployments/","title":"Introduction","text":"<p>This section details the installation and configuration of all the deployments run by the server. All of these deployments are run through Docker, so make sure you have it set up before reading any further.</p>"},{"location":"servers/deploy-us-east-1/deployments/#configuration","title":"Configuration","text":"<p>All deployments will be located in the home folder. In order to be a bit more organized, we'll create a folder for everything:</p> <pre><code>mkdir ~/deployments\n</code></pre>"},{"location":"servers/deploy-us-east-1/deployments/discord-free-games-notifier/","title":"Free Games Notifier for Discord","text":"<p>discord-free-games-notifier is a bot that notifies a channel whenever there's a free game on Steam or Epic Games.</p> <p>There is an official image for this service that we'll use: ghcr.io/moonstar-x/discord-free-games-notifier.</p>"},{"location":"servers/deploy-us-east-1/deployments/discord-free-games-notifier/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/deployments/discord-free-games-notifier\n</code></pre>"},{"location":"servers/deploy-us-east-1/deployments/discord-free-games-notifier/#docker-compose","title":"Docker Compose","text":"<p>Free Games Notifier will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  bot:\n    image: ghcr.io/moonstar-x/discord-free-games-notifier:latest\n    restart: unless-stopped\n    depends_on:\n      - redis\n      - postgres\n    environment:\n      TZ: America/Guayaquil\n      DISCORD_TOKEN: ${DISCORD_TOKEN}\n      DISCORD_SHARING_ENABLED: false\n      DISCORD_SHADING_COUNT: auto\n      DISCORD_PRESENCE_INTERVAL: 300000\n      REDIS_URI: redis://redis:6379\n      POSTGRES_HOST: postgres\n      POSTGRES_PORT: 5432\n      POSTGRES_DATABASE: ${POSTGRES_DATABASE}\n      POSTGRES_USER: ${POSTGRES_USER}\n      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}\n\n  crawler:\n    image: ghcr.io/moonstar-x/free-games-crawler:latest\n    restart: unless-stopped\n    depends_on:\n      - redis\n    environment:\n      TZ: America/Guayaquil\n      REDIS_URI: redis://redis:6379\n\n  redis:\n    image: redis:7.4-rc2-alpine\n    restart: unless-stopped\n    command: redis-server --save 60 1 --loglevel warning\n    volumes:\n      - ./crawler-data:/data\n\n  postgres:\n    image: postgres:15-alpine\n    restart: unless-stopped\n    volumes:\n      - ./data:/var/lib/postgresql/data\n    environment:\n      POSTGRES_DB: ${POSTGRES_DATABASE}\n      POSTGRES_USER: ${POSTGRES_USER}\n      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}\n</code></pre>"},{"location":"servers/deploy-us-east-1/deployments/discord-free-games-notifier/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DISCORD_TOKEN=\nPOSTGRES_USER=\nPOSTGRES_PASSWORD=\nPOSTGRES_DATABASE=\n</code></pre>"},{"location":"servers/deploy-us-east-1/deployments/discord-free-games-notifier/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/deploy-us-east-1/deployments/discord-text-to-speech/","title":"Text-to-Speech for Discord","text":"<p>discord-tts-bot is a bot that uses the Google Translate API to utter the messages you send to the bot in any language.</p> <p>There is an official image for this service that we'll use: moonstarx/discord-tts-bot.</p>"},{"location":"servers/deploy-us-east-1/deployments/discord-text-to-speech/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/deployments/discord-tts-bot\n</code></pre>"},{"location":"servers/deploy-us-east-1/deployments/discord-text-to-speech/#docker-compose","title":"Docker Compose","text":"<p>Text-to-Speech will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  bot:\n    image: moonstarx/discord-tts-bot:latest\n    restart: unless-stopped\n    depends_on:\n      - redis\n    volumes:\n      - ./data:/opt/app/data\n    environment:\n      TZ: America/Guayaquil\n      DISCORD_TOKEN: ${DISCORD_TOKEN}\n      DISCORD_PREFIX: $$\n      DISCORD_OWNER_ID: ${DISCORD_OWNER_ID}\n      DISCORD_DEFAULT_DISCONNECT_TIMEOUT: 10\n      DISCORD_PROVIDER_TYPE: redis\n      DISCORD_REDIS_URL: redis://redis:6379\n\n  redis:\n    image: redis:latest\n    restart: unless-stopped\n    volumes:\n      - ./data:/data\n    command: redis-server --save 60 1 --loglevel warning\n    environment:\n      TZ: America/Guayaquil\n</code></pre>"},{"location":"servers/deploy-us-east-1/deployments/discord-text-to-speech/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DISCORD_TOKEN=\nDISCORD_OWNER_ID=\n</code></pre>"},{"location":"servers/deploy-us-east-1/deployments/discord-text-to-speech/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/deploy-us-east-1/services/","title":"Introduction","text":"<p>This section details the installation and configuration of all the services run by the server. All of these services are run through Docker, so make sure you have it set up before reading any further.</p>"},{"location":"servers/deploy-us-east-1/services/#configuration","title":"Configuration","text":"<p>All services will be located in the home folder. In order to be a bit more organized, we'll create a folder for everything:</p> <pre><code>mkdir ~/services\n</code></pre>"},{"location":"servers/deploy-us-east-1/services/management/","title":"Initialization","text":"<p>All the services inside this section will be run through Docker. Since we'll use Docker Compose to execute the services, we'll create a folder on the main user's home folder dedicated to management services.</p> <pre><code>mkdir ~/services/management\n</code></pre> <p>For each service created, there will be a subfolder where a <code>docker-compose.yml</code> file will be located, alongside any data volumes required and even a <code>Dockerfile</code> if required.</p>"},{"location":"servers/deploy-us-east-1/services/management/portainer-agent/","title":"Portainer Agent","text":"<p>Portainer is a web UI for Docker which allows us to have an insight on all the containers running on our server.</p> <p>The Portainer agent allows you to expose the machine's Docker management to another Portainer service hosted elsewhere. We're using the agent in this case to use the main Portainer service to manage this one.</p> <p>There is an official image for this service that we'll use: portainer/agent.</p>"},{"location":"servers/deploy-us-east-1/services/management/portainer-agent/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/management/portainer-agent\n</code></pre>"},{"location":"servers/deploy-us-east-1/services/management/portainer-agent/#docker-compose","title":"Docker Compose","text":"<p>Portainer Agent will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  agent:\n    image: portainer/agent:latest\n    restart: unless-stopped\n    ports:\n      - 9001:9001\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - /var/lib/docker/volumes:/var/lib/docker/volumes\n    environment:\n      TZ: America/Guayaquil\n</code></pre>"},{"location":"servers/deploy-us-east-1/services/management/portainer-agent/#add-to-portainer","title":"Add to Portainer","text":"<p>In your main Portainer service,</p> <ol> <li>Head over to <code>Environments &gt; Add environment</code>.</li> <li>Pick <code>Docker Standalone</code> and click on <code>Start wizard</code>.</li> <li>Select <code>Agent</code>, set a <code>Name</code> for your agent and paste your server's address with <code>9001</code> as the port into <code>Environment address</code>.</li> <li>Finally, click <code>Connect</code>.</li> </ol> <p>And that's it, you can now manage your server's Docker services from your main Portainer service.</p>"},{"location":"servers/deploy-us-east-1/services/management/portainer-agent/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/deploy-us-east-1/services/networking/","title":"Initialization","text":"<p>All the services inside this section will be run through Docker. Since we'll use Docker Compose to execute the services, we'll create a folder on the main user's home folder dedicated to networking services.</p> <pre><code>mkdir ~/services/networking\n</code></pre> <p>For each service created, there will be a subfolder where a <code>docker-compose.yml</code> file will be located, alongside any data volumes required and even a <code>Dockerfile</code> if required.</p>"},{"location":"servers/deploy-us-east-1/services/networking/tailscale/","title":"Tailscale","text":"<p>Tailscale is a virtual LAN service, similar to Hamachi, that allows you to have your services exposed through a VPN.</p> <p>There is an official image for this service that we'll use: tailscale/tailscale.</p>"},{"location":"servers/deploy-us-east-1/services/networking/tailscale/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/networking/tailscale\n</code></pre>"},{"location":"servers/deploy-us-east-1/services/networking/tailscale/#getting-an-auth-key","title":"Getting an Auth Key","text":"<p>First head over to your Tailscale account's Dashboard &gt; Settings &gt; Keys and create <code>Generate auth key...</code>. You can name this key whatever you want and set the expiry to 1 day since we'll use it right off the bat.</p> <p>Once you generate it, copy it and save it somewhere, we'll use it in the docker-compose.yml file.</p>"},{"location":"servers/deploy-us-east-1/services/networking/tailscale/#docker-compose","title":"Docker Compose","text":"<p>Tailscale will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  vpn:\n    image: tailscale/tailscale:latest\n    restart: unless-stopped\n    network_mode: host\n    cap_add:\n      - NET_ADMIN\n      - SYS_MODULE\n    volumes:\n      - /dev/net/tun:/dev/net/tun\n      - ./data:/var/lib/tailscale\n    environment:\n      TZ: America/Guayaquil\n      TS_AUTHKEY: ${TAILSCALE_AUTH_KEY}\n      TS_EXTRA_ARGS: --advertise-tags=tag:container --advertise-exit-node --accept-routes\n      TS_STATE_DIR: /var/lib/tailscale\n      TS_USERSPACE: false\n</code></pre>"},{"location":"servers/deploy-us-east-1/services/networking/tailscale/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>TAILSCALE_AUTH_KEY=\n</code></pre>"},{"location":"servers/deploy-us-east-1/services/networking/tailscale/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/dev-ec-uio-1/configuration/","title":"Introduction","text":"<p>This section contains details of the <code>dev-ec-uio-1</code> server.</p> <p>This server is mostly used for development purposes.</p>"},{"location":"servers/dev-ec-uio-1/configuration/#server-specs","title":"Server Specs","text":"<p>This server is a Beelink Mini S PC with the following specs:</p> <ul> <li>OS: Ubuntu Server 24.04 LTS 64-bit</li> <li>CPU: Intel N150 - 4 Cores @ 3.6GHz</li> <li>RAM: 16GB of RAM DDR4</li> <li>Motherboard: Beelink Mini S13</li> <li>Storage:<ol> <li>512GB Pre-installed M.2 SSD</li> <li>4TB Toshiba USB 3.0 HDD</li> </ol> </li> </ul>"},{"location":"servers/dev-ec-uio-1/configuration/custom-scripts/","title":"Custom Scripts","text":"<p>We will create some custom scripts that will help us with certain tasks. For this, we'll create the following folder:</p> <pre><code>mkdir -p /usr/local/bin\n</code></pre> <p>Then inside this folder we'll insert all the scripts that we'll add here. Make sure to make them executable with:</p> <pre><code>chmod +x &lt;file&gt;\n</code></pre>"},{"location":"servers/dev-ec-uio-1/configuration/custom-scripts/#custom-docker-update","title":"<code>custom-docker-update</code>","text":"<p>We'll use this script to manually update docker compose containers.</p> <p>Usage</p> <p>Run <code>custom-docker-update</code> inside the folder where <code>docker-compose.yml</code> is located to update the container images used.</p> <pre><code>#!/bin/bash\n\necho \"Stopping containers...\"\ndocker compose stop\n\necho \"Removing containers...\"\ndocker compose rm -f\n\necho \"Pulling images...\"\ndocker compose pull\n\necho \"Restarting containers...\"\ndocker compose up -d\n</code></pre>"},{"location":"servers/dev-ec-uio-1/configuration/custom-scripts/#custom-docker-restart","title":"<code>custom-docker-restart</code>","text":"<p>We'll use this script to completely restart docker compose containers, this removes the containers and restarts them.</p> <p>Usage</p> <p>Run <code>custom-docker-restart</code> inside the folder where <code>docker-compose.yml</code> is located to update the container images used.</p> <pre><code>#!/bin/bash\n\ndocker compose rm -fs &amp;&amp; docker compose up -d\n</code></pre>"},{"location":"servers/dev-ec-uio-1/configuration/docker/","title":"Docker","text":"<p>All the services in the server will be run through Docker. We'll need to install it first.</p>"},{"location":"servers/dev-ec-uio-1/configuration/docker/#installation","title":"Installation","text":"<p>To install Docker, simply run the following commands:</p> <pre><code>curl -fsSL https://get.docker.com -o get-docker.sh\nsudo sh ./get-docker.sh\n</code></pre> <p>Once it's done, you can remove the downloaded script:</p> <pre><code>rm get-docker.sh\n</code></pre>"},{"location":"servers/dev-ec-uio-1/configuration/docker/#permissions","title":"Permissions","text":"<p>We'll add the required permissions for our user into the <code>docker</code> group.</p> <pre><code>sudo groupadd docker\nsudo gpasswd -a $USER docker\n</code></pre>"},{"location":"servers/dev-ec-uio-1/configuration/installation/","title":"Installation","text":"<p>The server will be running Ubuntu Server 24.04 LTS 64-bit in headless mode, meaning that no DE or WM will be used. The installation is quick and assisted by its own installation wizard. For better performance, you should install the minimal version which does not include any graphical interface other than the command line. Additionally, no packages were installed from the installation wizard.</p>"},{"location":"servers/dev-ec-uio-1/configuration/installation/#post-installation","title":"Post-Installation","text":"<p>As a general rule of thumb, after installing the OS it is recommended to update the sources and packages:</p> <pre><code>sudo apt-get update &amp;&amp; sudo apt-get upgrade\n</code></pre>"},{"location":"servers/dev-ec-uio-1/configuration/installation/#configuring-date-and-time","title":"Configuring Date and Time","text":"<p>By default, the OS will be installed with GMT+0 as the timezone. We'll change this to conform with our real timezone which is GMT-5.</p> <pre><code>sudo timedatectl set-timezone America/Guayaquil\n</code></pre>"},{"location":"servers/dev-ec-uio-1/configuration/installation/#packages","title":"Packages","text":"<p>Here's a list of packages I like to have on the server.</p> <pre><code>sudo apt-get install openssh-server openssh-client net-tools neofetch nload progress nano iputils-ping htop git speedtest-cli\n</code></pre>"},{"location":"servers/dev-ec-uio-1/configuration/installation/#firewall","title":"Firewall","text":"<p>UFW is a friendly frontend for iptables that makes it a lot easier to add connection rules to your firewall.</p> <p>We'll need to install UFW and set it up.</p> <pre><code>sudo apt-get install ufw\nsudo ufw default allow outgoing\nsudo ufw default deny incoming\nsudo ufw allow ssh\nsudo ufw enable\n</code></pre> <p>The commands should be pretty self-explanatory, these default the firewall to allow any connections going from the server to the Internet and deny any incoming connections from the Internet to the server.</p> <p>Make sure to also enable the <code>ssh</code> ports, otherwise you may get locked out of your system remotely and may need to physically configure the firewall to allow SSH connections.</p>"},{"location":"servers/dev-ec-uio-1/configuration/installation/#usage","title":"Usage","text":"<p>A very good command to check UFW's status (if it's enabled or disabled) and see all the custom rules added and active is:</p> <pre><code>sudo ufw status\n</code></pre> <p>You can add a new rule by using:</p> <pre><code>sudo ufw allow &lt;PORT_RANGE&gt;/&lt;PROTOCOL&gt;\n</code></pre>"},{"location":"servers/dev-ec-uio-1/configuration/installation/#git","title":"Git","text":"<p>By default, <code>git</code> does not have a credential store configured, so make sure you run the following command to allow git operations in protected repos:</p> <pre><code>git config --global credential.helper store\n</code></pre>"},{"location":"servers/dev-ec-uio-1/configuration/mounting-drives/","title":"Mounting Drives","text":"<p>This server has at least one USB hard drive that remains constantly connected. We need this drive to mount on system startup, for this, we'll need to set up the <code>fstab</code>.</p>"},{"location":"servers/dev-ec-uio-1/configuration/mounting-drives/#getting-drive-uuids","title":"Getting Drive UUIDs","text":"<p>In order to get the UUIDs of the drive in question, it is necessary to plug them in. Once this is done, execute the following:</p> <pre><code>lsblk -o NAME,FSTYPE,UUID\n</code></pre> <p>This will give an output similar to the following:</p> <pre><code>NAME   FSTYPE UUID\nsda           \n\u251c\u2500sda1 vfat   7811-FFBE\n\u2514\u2500sda2 ext4   3c98de9f-dc43-4e8d-85aa-767475ea957b\nsdb    ext4   418987da-2351-11e9-aec8-b8975ad7798b\n</code></pre> <p>If you cannot tell which drive is which, you can also run the following:</p> <pre><code>sudo fdisk -l\n</code></pre> <p>Which will give out an output similar to the following:</p> <pre><code>Disk /dev/sdb: 1.82 TiB, 2000398934016 bytes, 3907029168 sectors\nDisk model: Hitachi HUA72302\nUnits: sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\n\n\nDisk /dev/sda: 223.57 GiB, 240057409536 bytes, 468862128 sectors\nDisk model: CT240BX500SSD1  \nUnits: sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisklabel type: gpt\nDisk identifier: 18C45280-7C95-4D8C-8033-81277842D6FF\n\nDevice       Start       End   Sectors   Size Type\n/dev/sda1     2048   2203647   2201600     1G EFI System\n/dev/sda2  2203648 468858879 466655232 222.5G Linux filesystem\n</code></pre> <p>Notice the <code>Device</code> value for each, reference it with the output from the previous command, and you'll now be able to tell the identifier of the partitions you need.</p>"},{"location":"servers/dev-ec-uio-1/configuration/mounting-drives/#preparing-the-folders","title":"Preparing the Folders","text":"<p>We'll mount the hard drives in <code>/media</code>, for this we'll create the folders like so:</p> <pre><code>sudo mkdir /media/my_drive\n</code></pre> <p>You may also change the ownership on these folders if it causes any problem.</p> <pre><code>sudo chown -R 1000:1000 /media/my_drive\n</code></pre>"},{"location":"servers/dev-ec-uio-1/configuration/mounting-drives/#modifying-fstab","title":"Modifying <code>fstab</code>","text":"<p>Danger</p> <p>Make sure to have physical access to the server in case editing this file breaks your installation. If your file is not correct, the system will boot in safe-mode with SSH disabled.</p> <p>We'll modify the <code>/etc/fstab</code> file.</p> <pre><code>sudo nano /etc/fstab\n</code></pre> <p>And we'll add a new line for each hard drive with the following structure:</p> <pre><code>UUID=$UUID $DIR $FORMAT defaults 0 0\n</code></pre> <p>In our case, we'll add the following lines:</p> <pre><code>/dev/disk/by-uuid/98e05af0-fa9c-4952-a8d6-e09280626835 /media/my_drive ext4 defaults 0 0\n</code></pre> <p>Finally, reboot the server. The drive should now be automatically mounted.</p>"},{"location":"servers/dev-ec-uio-1/services/","title":"Introduction","text":"<p>This section details the installation and configuration of all the services run by the server. All of these services are run through Docker, so make sure you have it set up before reading any further.</p>"},{"location":"servers/dev-ec-uio-1/services/#configuration","title":"Configuration","text":"<p>All services will be located in the home folder. In order to be a bit more organized, we'll create a folder for everything:</p> <pre><code>mkdir ~/services\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/ai/","title":"Initialization","text":"<p>All the services inside this section will be run through Docker. Since we'll use Docker Compose to execute the services, we'll create a folder on the main user's home folder dedicated to AI services.</p> <pre><code>mkdir ~/services/ai\n</code></pre> <p>For each service created, there will be a subfolder where a <code>docker-compose.yml</code> file will be located, alongside any data volumes required and even a <code>Dockerfile</code> if required.</p>"},{"location":"servers/dev-ec-uio-1/services/ai/langfuse/","title":"Langfuse","text":"<p>Langfuse is a self-hosted tracing tool for LLMs.</p> <p>There is an official image for this service that we'll use: langfuse/langfuse.</p>"},{"location":"servers/dev-ec-uio-1/services/ai/langfuse/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/ai/langfuse\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/ai/langfuse/#docker-compose","title":"Docker Compose","text":"<p>Langfuse will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  worker:\n    image: langfuse/langfuse-worker:3\n    restart: unless-stopped\n    depends_on: &amp;langfuse-depends-on\n      postgres:\n        condition: service_healthy\n      minio:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n      clickhouse:\n        condition: service_healthy\n    environment: &amp;langfuse-worker-env\n      TZ: America/Guayaquil\n      DATABASE_URL: postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DATABASE}\n      SALT: ${SALT}\n      ENCRYPTION_KEY: ${ENCRYPTION_KEY}\n      TELEMETRY_ENABLED: false\n      LANGFUSE_ENABLE_EXPERIMENTAL_FEATURES: true\n      AUTH_DISABLE_SIGNUP: true\n      CLICKHOUSE_MIGRATION_URL: clickhouse://clickhouse:9000\n      CLICKHOUSE_URL: http://clickhouse:8123\n      CLICKHOUSE_USER: ${CLICKHOUSE_USER}\n      CLICKHOUSE_PASSWORD: ${CLICKHOUSE_PASSWORD}\n      CLICKHOUSE_CLUSTER_ENABLED: false\n      REDIS_HOST: redis\n      REDIS_PORT: 6379\n      REDIS_AUTH: ${REDIS_AUTH}\n      REDIS_TLS_ENABLED: false\n      LANGFUSE_S3_EVENT_UPLOAD_BUCKET: ${MINIO_BUCKET}\n      LANGFUSE_S3_EVENT_UPLOAD_REGION: ${MINIO_REGION}\n      LANGFUSE_S3_EVENT_UPLOAD_ACCESS_KEY_ID: ${MINIO_ROOT_USER}\n      LANGFUSE_S3_EVENT_UPLOAD_SECRET_ACCESS_KEY: ${MINIO_ROOT_PASSWORD}\n      LANGFUSE_S3_EVENT_UPLOAD_ENDPOINT: http://minio:9000\n      LANGFUSE_S3_EVENT_UPLOAD_FORCE_PATH_STYLE: true\n      LANGFUSE_S3_EVENT_UPLOAD_PREFIX: events/\n      LANGFUSE_S3_MEDIA_UPLOAD_BUCKET: ${MINIO_BUCKET}\n      LANGFUSE_S3_MEDIA_UPLOAD_REGION: ${MINIO_REGION}\n      LANGFUSE_S3_MEDIA_UPLOAD_ACCESS_KEY_ID: ${MINIO_ROOT_USER}\n      LANGFUSE_S3_MEDIA_UPLOAD_SECRET_ACCESS_KEY: ${MINIO_ROOT_PASSWORD}\n      LANGFUSE_S3_MEDIA_UPLOAD_ENDPOINT: https://${DOMAIN_MINIO}\n      LANGFUSE_S3_MEDIA_UPLOAD_FORCE_PATH_STYLE: true\n      LANGFUSE_S3_MEDIA_UPLOAD_PREFIX: media/\n      LANGFUSE_S3_BATCH_EXPORT_ENABLED: false\n      LANGFUSE_S3_BATCH_EXPORT_BUCKET: ${MINIO_BUCKET}\n      LANGFUSE_S3_BATCH_EXPORT_REGION: ${MINIO_REGION}\n      LANGFUSE_S3_BATCH_EXPORT_PREFIX: exports/\n      LANGFUSE_S3_BATCH_EXPORT_ENDPOINT: http://minio:9000\n      LANGFUSE_S3_BATCH_EXPORT_EXTERNAL_ENDPOINT: https://${DOMAIN_MINIO}\n      LANGFUSE_S3_BATCH_EXPORT_ACCESS_KEY_ID: ${MINIO_ROOT_USER}\n      LANGFUSE_S3_BATCH_EXPORT_SECRET_ACCESS_KEY: ${MINIO_ROOT_PASSWORD}\n      LANGFUSE_S3_BATCH_EXPORT_FORCE_PATH_STYLE: true\n\n  web:\n    image: langfuse/langfuse:3\n    restart: unless-stopped\n    depends_on: *langfuse-depends-on\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - langfuse\n    expose:\n      - 3000\n    environment:\n      &lt;&lt;: *langfuse-worker-env\n      NEXTAUTH_URL: https://${DOMAIN_LANGFUSE}\n      NEXTAUTH_SECRET: ${NEXTAUTH_SECRET}\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.langfuse.rule: Host(`${DOMAIN_LANGFUSE}`)\n      traefik.http.routers.langfuse.entrypoints: public\n      traefik.http.routers.langfuse.service: langfuse@docker\n      traefik.http.services.langfuse.loadbalancer.server.port: 3000\n\n  minio:\n    image: minio/minio:latest\n    restart: unless-stopped\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - langfuse-minio\n    healthcheck:\n      test: [\"CMD\", \"mc\", \"ready\", \"local\"]\n      interval: 1s\n      timeout: 5s\n      retries: 5\n      start_period: 1s\n    entrypoint: sh\n    command: -c 'mkdir -p /data/langfuse &amp;&amp; minio server --address \":9000\" --console-address \":9001\" /data'\n    volumes:\n      - ./minio:/data\n    environment:\n      TZ: America/Guayaquil\n      MINIO_ROOT_USER: ${MINIO_ROOT_USER}\n      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD}\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.langfuse-minio.rule: Host(`${DOMAIN_MINIO}`)\n      traefik.http.routers.langfuse-minio.entrypoints: public\n      traefik.http.routers.langfuse-minio.service: langfuse-minio@docker\n      traefik.http.services.langfuse-minio.loadbalancer.server.port: 9000\n\n  postgres:\n    image: postgres:17\n    restart: unless-stopped\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U postgres\"]\n      interval: 3s\n      timeout: 3s\n      retries: 10\n    volumes:\n      - ./postgres:/var/lib/postgresql/data\n    environment:\n      TZ: America/Guayaquil\n      POSTGRES_DB: ${POSTGRES_DATABASE}\n      POSTGRES_USER: ${POSTGRES_USER}\n      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}\n\n  redis:\n    image: redis:7\n    restart: unless-stopped\n    healthcheck:\n      test: [\"CMD\", \"redis-cli\", \"ping\"]\n      interval: 3s\n      timeout: 10s\n      retries: 10\n    command: --requirepass ${REDIS_AUTH}\n    environment:\n      TZ: America/Guayaquil\n\n  clickhouse:\n    image: clickhouse/clickhouse-server:latest\n    restart: unless-stopped\n    healthcheck:\n      test: wget --no-verbose --tries=1 --spider http://localhost:8123/ping || exit 1\n      interval: 5s\n      timeout: 5s\n      retries: 10\n      start_period: 1s\n    volumes:\n      - ./clickhouse/data:/var/lib/clickhouse\n      - ./clickhouse/logs:/var/log/clickhouse-server\n    environment:\n      TZ: America/Guayaquil\n      CLICKHOUSE_DB: ${CLICKHOUSE_DATABASE}\n      CLICKHOUSE_USER: ${CLICKHOUSE_USER}\n      CLICKHOUSE_PASSWORD: ${CLICKHOUSE_PASSWORD}\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/ai/langfuse/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DOMAIN_LANGFUSE=\nDOMAIN_MINIO=\n\nPOSTGRES_DATABASE=\nPOSTGRES_USER=\nPOSTGRES_PASSWORD=\n\nREDIS_AUTH=\n\nCLICKHOUSE_DATABASE=\nCLICKHOUSE_USER=\nCLICKHOUSE_PASSWORD=\n\nMINIO_ROOT_USER=\nMINIO_ROOT_PASSWORD=\nMINIO_BUCKET=\nMINIO_REGION=\n\nSALT=\nENCRYPTION_KEY=\nNEXTAUTH_SECRET=\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/ai/langfuse/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/dev-ec-uio-1/services/ai/langfuse/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/dev-ec-uio-1/services/ai/ollama/","title":"Ollama","text":"<p>Ollama is a self-hosted tool that allows you to run open-source models on your own hardware.</p> <p>There is an official image for this service that we'll use: ollama/ollama.</p>"},{"location":"servers/dev-ec-uio-1/services/ai/ollama/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/ai/ollama\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/ai/ollama/#docker-compose","title":"Docker Compose","text":"<p>Ollama will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: ollama/ollama:latest\n    restart: unless-stopped\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - ollama\n    volumes:\n      - ./ollama:/root/.ollama\n    environment:\n      TZ: America/Guayaquil\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.ollama.rule: Host(`${DOMAIN_OLLAMA_LOCAL}`)\n      traefik.http.routers.ollama.entrypoints: local-https\n      traefik.http.routers.ollama.tls: true\n      traefik.http.routers.ollama.tls.certresolver: le\n      traefik.http.routers.ollama.service: ollama@docker\n      traefik.http.services.ollama.loadbalancer.server.port: 11434\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/ai/ollama/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DOMAIN_OLLAMA_LOCAL=\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/ai/ollama/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/dev-ec-uio-1/services/ai/ollama/#installing-models","title":"Installing Models","text":"<p>Inside the service folder, run the following command:</p> <pre><code>docker compose exec web /bin/sh\n</code></pre> <p>You can then pull your favorite models like so:</p> <pre><code>ollama run qwen2.5:3b\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/ai/ollama/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/dev-ec-uio-1/services/ai/open-webui/","title":"Open WebUI","text":"<p>Open WebUI is a self-hosted frontend to interact with LLMs.</p> <p>There is an official image for this service that we'll use: ghcr.io/open-webui/open-webui.</p>"},{"location":"servers/dev-ec-uio-1/services/ai/open-webui/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/ai/open-webui\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/ai/open-webui/#docker-compose","title":"Docker Compose","text":"<p>Open WebUI will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: ghcr.io/open-webui/open-webui:main\n    restart: unless-stopped\n    extra_hosts:\n      - host.docker.internal:host-gateway\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - open-webui\n    volumes:\n      - ./data:/app/backend/data\n    environment:\n      TZ: America/Guayaquil\n      OLLAMA_BASE_URL: ${OLLAMA_BASE_URL}\n      WEBUI_SECRET_KEY: ${SECRET_KEY}\n      WEBUI_URL: https://${DOMAIN_OPEN_WEBUI}\n      ENABLE_SIGNUP: false\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.open-webui.rule: Host(`${DOMAIN_OPEN_WEBUI}`)\n      traefik.http.routers.open-webui.entrypoints: public\n      traefik.http.routers.open-webui.service: open-webui@docker\n      traefik.http.services.open-webui.loadbalancer.server.port: 8080\n\n  proxy:\n    image: nginx:alpine\n    restart: unless-stopped\n    network_mode: host\n    volumes:\n      - ./nginx.conf:/etc/nginx/nginx.conf:ro\n    environment:\n      TZ: America/Guayaquil\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre> <p>Note</p> <p>The <code>proxy</code> container is completely optional, you might not need it. I'm using it to access an Ollama instance on a separate machine on my local network without having to expose the <code>web</code> container itself.</p>"},{"location":"servers/dev-ec-uio-1/services/ai/open-webui/#nginxconf","title":"<code>nginx.conf</code>","text":"<p>The contents of this file are as follows:</p> <pre><code>events {}\n\nhttp {\n    server {\n        listen 61000;\n\n        location / {\n            proxy_pass http://192.168.100.43:11434;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        }\n    }\n}\n</code></pre> <p>Info</p> <p>This proxy configuration acts as a route to forward all requests to the host machine on port <code>61000</code> to a machine on my local network on <code>192.168.100.43:11434</code> which is an Ollama instance on a separate machine.</p> <p>This way, from within the <code>web</code> container this LAN service becomes accessible on <code>host.docker.internal:61000</code>.</p>"},{"location":"servers/dev-ec-uio-1/services/ai/open-webui/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DOMAIN_OPEN_WEBUI=\nOLLAMA_BASE_URL=\nSECRET_KEY=\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/ai/open-webui/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/dev-ec-uio-1/services/ai/open-webui/#post-installation","title":"Post-Installation","text":"<p>In case you decide to use the <code>proxy</code> container as how I'm using it, you'll need to create a firewall rule.</p> <pre><code>sudo ufw allow 61000/tcp\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/ai/open-webui/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/dev-ec-uio-1/services/data/","title":"Initialization","text":"<p>All the services inside this section will be run through Docker. Since we'll use Docker Compose to execute the services, we'll create a folder on the main user's home folder dedicated to data services.</p> <pre><code>mkdir ~/services/data\n</code></pre> <p>For each service created, there will be a subfolder where a <code>docker-compose.yml</code> file will be located, alongside any data volumes required and even a <code>Dockerfile</code> if required.</p>"},{"location":"servers/dev-ec-uio-1/services/data/wakapi/","title":"Wakapi","text":"<p>Wakapi is a self-hosted code statistics tracker similar to Wakatime.</p> <p>There is an official image for this service that we'll use: ghcr.io/muety/wakapi.</p>"},{"location":"servers/dev-ec-uio-1/services/data/wakapi/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/data/wakapi\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/data/wakapi/#docker-compose","title":"Docker Compose","text":"<p>Wakapi will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: ghcr.io/muety/wakapi:latest\n    restart: unless-stopped\n    depends_on:\n      - db\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - wakapi\n    environment:\n      TZ: America/Guayaquil\n      ENVIRONMENT: prod\n      WAKAPI_LEADERBOARD_ENABLED: false\n      WAKAPI_PUBLIC_URL: https://${DOMAIN_WAKAPI}\n      WAKAPI_PASSWORD_SALT: ${SALT}\n      WAKAPI_ALLOW_SIGNUP: false\n      WAKAPI_DISABLE_FRONTPAGE: true\n      WAKAPI_EXPOSE_METRICS: true\n      WAKAPI_DB_TYPE: postgres\n      WAKAPI_DB_NAME: ${POSTGRES_DB}\n      WAKAPI_DB_USER: ${POSTGRES_USER}\n      WAKAPI_DB_PASSWORD: ${POSTGRES_PASSWORD}\n      WAKAPI_DB_HOST: db\n      WAKAPI_DB_PORT: 5432\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.wakapi.rule: Host(`${DOMAIN_WAKAPI}`)\n      traefik.http.routers.wakapi.entrypoints: public\n      traefik.http.routers.wakapi.service: wakapi@docker\n      traefik.http.services.wakapi.loadbalancer.server.port: 3000\n\n  db:\n    image: postgres:17\n    restart: unless-stopped\n    volumes:\n      - ./data:/var/lib/postgresql/data\n    environment:\n      TZ: America/Guayaquil\n      POSTGRES_DB: ${POSTGRES_DB}\n      POSTGRES_USER: ${POSTGRES_USER}\n      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/data/wakapi/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>SALT=\nPOSTGRES_DB=\nPOSTGRES_USER=\nPOSTGRES_PASSWORD=\nDOMAIN_WAKAPI=\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/data/wakapi/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/dev-ec-uio-1/services/data/wakapi/#post-installation","title":"Post-Installation","text":"<p>You'll notice that the <code>WAKAPI_ALLOW_SIGNUP</code> variable is set to <code>false</code> in the <code>docker-compose.yml</code> file. Consider setting this to <code>true</code> the first time you start the service up, sign up with your user, and then re-disable this.</p>"},{"location":"servers/dev-ec-uio-1/services/data/wakapi/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/dev-ec-uio-1/services/development/","title":"Initialization","text":"<p>All the services inside this section will be run through Docker. Since we'll use Docker Compose to execute the services, we'll create a folder on the main user's home folder dedicated to development services.</p> <pre><code>mkdir ~/services/development\n</code></pre> <p>For each service created, there will be a subfolder where a <code>docker-compose.yml</code> file will be located, alongside any data volumes required and even a <code>Dockerfile</code> if required.</p>"},{"location":"servers/dev-ec-uio-1/services/development/gitea-runners/","title":"Gitea Runners","text":"<p>Gitea is a self-hosted git server, useful for having a private VCS solution. Gitea comes with CI support with Act Runners which essentially emulate GitHub Actions. </p> <p>There is an official image for this service that we'll use: gitea/act_runner.</p>"},{"location":"servers/dev-ec-uio-1/services/development/gitea-runners/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/development/gitea-runners\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/development/gitea-runners/#getting-a-token","title":"Getting a Token","text":"<p>In order to connect a runner with your Gitea instance you'll need a token. This token can be found by heading over to <code>https://my.gitea.instance/-/admin/actions/runners</code> or <code>Site Administration &gt; Actions &gt; Runners</code>. Here you'll find a button that says <code>Create new Runner</code> click on it to get the registration token for your instance.</p>"},{"location":"servers/dev-ec-uio-1/services/development/gitea-runners/#docker-compose","title":"Docker Compose","text":"<p>Gitea Runners will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  runner-1:\n    image: gitea/act_runner:latest\n    restart: unless-stopped\n    ports:\n      - 20000:20000\n    volumes:\n      - ./runner-1/data:/data\n      - ./cache:/root/.cache\n      - ./runner-1/config.yaml:/config.yaml\n      - /var/run/docker.sock:/var/run/docker.sock\n    environment:\n      TZ: America/Guayaquil\n      GITEA_INSTANCE_URL: ${GITEA_URL}\n      GITEA_RUNNER_REGISTRATION_TOKEN: ${RUNNER_TOKEN}\n      GITEA_RUNNER_NAME: local-runner-1\n      CONFIG_FILE: /config.yaml\n\n  runner-2:\n    image: gitea/act_runner:latest\n    restart: unless-stopped\n    ports:\n      - 20010:20010\n    volumes:\n      - ./runner-2/data:/data\n      - ./cache:/root/.cache\n      - ./runner-2/config.yaml:/config.yaml\n      - /var/run/docker.sock:/var/run/docker.sock\n    environment:\n      TZ: America/Guayaquil\n      GITEA_INSTANCE_URL: ${GITEA_URL}\n      GITEA_RUNNER_REGISTRATION_TOKEN: ${RUNNER_TOKEN}\n      GITEA_RUNNER_NAME: local-runner-2\n      CONFIG_FILE: /config.yaml\n\n  runner-3:\n    image: gitea/act_runner:latest\n    restart: unless-stopped\n    ports:\n      - 20020:20020\n    volumes:\n      - ./runner-3/data:/data\n      - ./cache:/root/.cache\n      - ./runner-3/config.yaml:/config.yaml\n      - /var/run/docker.sock:/var/run/docker.sock\n    environment:\n      TZ: America/Guayaquil\n      GITEA_INSTANCE_URL: ${GITEA_URL}\n      GITEA_RUNNER_REGISTRATION_TOKEN: ${RUNNER_TOKEN}\n      GITEA_RUNNER_NAME: local-runner-3\n      CONFIG_FILE: /config.yaml\n</code></pre> <p>Note</p> <p>I've made 3 containers with the same image. It's up to you if you want multiple or if only one is enough.</p>"},{"location":"servers/dev-ec-uio-1/services/development/gitea-runners/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>GITEA_URL=\n\nRUNNER_TOKEN=\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/development/gitea-runners/#configuration","title":"Configuration","text":"<p>Make sure to create the <code>runner</code> folders according to the volume defined in each container and inside each of these folders create a <code>config.yaml</code> file with the following content:</p> <pre><code>cache:\n  enabled: true\n  dir: ''\n  host: LAN_HOST\n  port: 20000\n</code></pre> <p>Replace <code>LAN_HOST</code> with the LAN IP of your server. (i.e. <code>10.0.0.22</code> or `192.168.100.22).</p> <p>Additionally, make sure to allow the port you've defined in the config through your firewall:</p> <pre><code>sudo ufw allow 20000/tcp\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/development/gitea-runners/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/dev-ec-uio-1/services/development/gitea/","title":"Gitea","text":"<p>Gitea is a self-hosted git server, useful for having a private VCS solution.</p> <p>There is an official image for this service that we'll use: gitea/gitea.</p>"},{"location":"servers/dev-ec-uio-1/services/development/gitea/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/development/gitea\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/development/gitea/#docker-compose","title":"Docker Compose","text":"<p>Gitea will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: gitea/gitea:latest\n    restart: unless-stopped\n    depends_on:\n      - db\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - gitea\n    volumes:\n      - ./data:/data\n    environment:\n      TZ: America/Guayaquil\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.gitea.rule: Host(`${DOMAIN_GITEA}`)\n      traefik.http.routers.gitea.entrypoints: public\n      traefik.http.routers.gitea.service: gitea@docker\n      traefik.http.services.gitea.loadbalancer.server.port: 3000\n      traefik.http.middlewares.gitea-headers.headers.customrequestheaders.X-Forwarded-Proto: https\n      traefik.http.middlewares.gitea-headers.headers.customrequestheaders.Host: ${DOMAIN_GITEA}\n      traefik.http.routers.gitea.middlewares: gitea-headers\n\n  db:\n    image: postgres:14\n    restart: unless-stopped\n    volumes:\n      - ./db:/var/lib/postgresql/data\n    environment:\n      TZ: America/Guayaquil\n      POSTGRES_DB: ${POSTGRES_DB}\n      POSTGRES_USER: ${POSTGRES_USER}\n      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/development/gitea/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>POSTGRES_DB=\nPOSTGRES_USER=\nPOSTGRES_PASSWORD=\n\nDOMAIN_GITEA=\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/development/gitea/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/dev-ec-uio-1/services/development/gitea/#post-installation","title":"Post-Installation","text":"<p>Once you have started the server once, edit the config file located inside the <code>data</code> volume:</p> <pre><code>nano data/gitea/conf/app.ini\n</code></pre> <p>And make sure to have the following lines:</p> <pre><code>[service]\nDISABLE_REGISTRATION = true\n</code></pre> <p>This will make sure that nobody else can register into your server without your knowledge.</p>"},{"location":"servers/dev-ec-uio-1/services/development/gitea/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/dev-ec-uio-1/services/development/glitchtip/","title":"Glitchtip","text":"<p>Glitchtip is a self-hosted error tracking similar to Sentry.</p> <p>There is an official image for this service that we'll use: glitchtip/glitchtip.</p>"},{"location":"servers/dev-ec-uio-1/services/development/glitchtip/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/development/glitchtip\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/development/glitchtip/#docker-compose","title":"Docker Compose","text":"<p>Glitchtip will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: glitchtip/glitchtip:latest\n    restart: unless-stopped\n    depends_on:\n      db:\n        condition: service_healthy\n      cache:\n        condition: service_started\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - glitchtip\n    volumes:\n      - ./uploads:/code/uploads\n    environment:\n      TZ: America/Guayaquil\n      DATABASE_URL: postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DATABASE}\n      REDIS_URL: redis://cache:6379/1\n      SECRET_KEY: ${SECRET_KEY}\n      EMAIL_URL: consolemail://\n      GLITCHTIP_DOMAIN: https://${DOMAIN_GLITCHTIP}\n      DEFAULT_FROM_EMAIL: ${FROM_EMAIL}\n      CELERY_WORKER_AUTOSCALE: 1,3\n      ENABLE_USER_REGISTRATION: false\n      ENABLE_ORGANIZATION_CREATION: false\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.glitchtip.rule: Host(`${DOMAIN_GLITCHTIP}`)\n      traefik.http.routers.glitchtip.entrypoints: public\n      traefik.http.routers.glitchtip.service: glitchtip@docker\n      traefik.http.services.glitchtip.loadbalancer.server.port: 8080\n      traefik.http.middlewares.glitchtip-headers.headers.customrequestheaders.X-Forwarded-Proto: https\n      traefik.http.middlewares.glitchtip-headers.headers.customrequestheaders.Host: ${DOMAIN_GLITCHTIP}\n      traefik.http.routers.glitchtip.middlewares: glitchtip-headers\n\n  worker:\n    image: glitchtip/glitchtip:latest\n    restart: unless-stopped\n    depends_on:\n      db:\n        condition: service_healthy\n      cache:\n        condition: service_started\n    command: ./bin/run-celery-with-beat.sh\n    volumes:\n      - ./uploads:/code/uploads\n    environment:\n      TZ: America/Guayaquil\n      DATABASE_URL: postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DATABASE}\n      REDIS_URL: redis://cache:6379/1\n      SECRET_KEY: ${SECRET_KEY}\n      EMAIL_URL: consolemail://\n      GLITCHTIP_DOMAIN: https://${DOMAIN_GLITCHTIP}\n      DEFAULT_FROM_EMAIL: ${FROM_EMAIL}\n      CELERY_WORKER_AUTOSCALE: 1,3\n      ENABLE_USER_REGISTRATION: false\n      ENABLE_ORGANIZATION_CREATION: false\n\n  migrate:\n    image: glitchtip/glitchtip:latest\n    restart: no\n    depends_on:\n      db:\n        condition: service_healthy\n      cache:\n        condition: service_started\n    command: ./bin/run-migrate.sh\n    environment:\n      TZ: America/Guayaquil\n      DATABASE_URL: postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DATABASE}\n      REDIS_URL: redis://cache:6379/1\n      SECRET_KEY: ${SECRET_KEY}\n      EMAIL_URL: consolemail://\n      GLITCHTIP_DOMAIN: https://${DOMAIN_GLITCHTIP}\n      DEFAULT_FROM_EMAIL: ${FROM_EMAIL}\n      CELERY_WORKER_AUTOSCALE: 1,3\n      ENABLE_USER_REGISTRATION: false\n      ENABLE_ORGANIZATION_CREATION: false\n\n  db:\n    image: postgres:17\n    restart: unless-stopped\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n    volumes:\n      - ./data:/var/lib/postgresql/data\n    environment:\n      TZ: America/Guayaquil\n      POSTGRES_DB: ${POSTGRES_DATABASE}\n      POSTGRES_USER: ${POSTGRES_USER}\n      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}\n\n  cache:\n    image: valkey/valkey:latest\n    restart: unless-stopped\n    environment:\n      TZ: America/Guayaquil\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/development/glitchtip/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>POSTGRES_DATABASE=\nPOSTGRES_USER=\nPOSTGRES_PASSWORD=\n\nSECRET_KEY=\nFROM_EMAIL=\n\nDOMAIN_GLITCHTIP=\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/development/glitchtip/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/dev-ec-uio-1/services/development/glitchtip/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/dev-ec-uio-1/services/development/kroki/","title":"Kroki","text":"<p>Kroki is a web service that exposes diagram services that allow you to generate dynamic diagrams from a <code>GET</code> or <code>POST</code> request. The diagrams are typically defined by text.</p> <p>There is an official image for this service that we'll use: yuzutech/kroki.</p>"},{"location":"servers/dev-ec-uio-1/services/development/kroki/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/development/kroki\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/development/kroki/#docker-compose","title":"Docker Compose","text":"<p>Kroki will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: yuzutech/kroki:latest\n    restart: unless-stopped\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - kroki\n    environment:\n      TZ: America/Guayaquil\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.kroki.rule: Host(`${DOMAIN_KROKI_LOCAL}`) || Host(`${DOMAIN_KROKI_VPN}`)\n      traefik.http.routers.kroki.entrypoints: local-https\n      traefik.http.routers.kroki.tls: true\n      traefik.http.routers.kroki.tls.certresolver: le\n      traefik.http.routers.kroki.service: kroki@docker\n      traefik.http.services.kroki.loadbalancer.server.port: 8000\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/development/kroki/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DOMAIN_KROKI_LOCAL=\nDOMAIN_KROKI_VPN=\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/development/kroki/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/dev-ec-uio-1/services/development/kroki/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/dev-ec-uio-1/services/development/penpot/","title":"Penpot","text":"<p>Penpot is a self-hosted UI/UX design tool similar to Figma.</p> <p>There is an official image for this service that we'll use: penpotapp/frontend, penpotapp/backend, and penpotapp/exporter.</p>"},{"location":"servers/dev-ec-uio-1/services/development/penpot/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/development/penpot\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/development/penpot/#docker-compose","title":"Docker Compose","text":"<p>Penpot will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  penpot-frontend:\n    image: penpotapp/frontend:latest\n    restart: unless-stopped\n    depends_on:\n      - penpot-backend\n      - penpot-exporter\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - penpot\n    volumes:\n      - ./assets:/opt/data/assets\n    environment:\n      TZ: America/Guayaquil\n      PENPOT_FLAGS: disable-registration enable-login-with-password enable-webhooks\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.penpot.rule: Host(`${DOMAIN_PENPOT}`)\n      traefik.http.routers.penpot.entrypoints: public\n      traefik.http.routers.penpot.service: penpot@docker\n      traefik.http.services.penpot.loadbalancer.server.port: 8080\n\n  penpot-backend:\n    image: penpotapp/backend:latest\n    restart: unless-stopped\n    depends_on:\n      - penpot-postgres\n      - penpot-redis\n    volumes:\n      - ./assets:/opt/data/assets\n    environment:\n      TZ: America/Guayaquil\n      PENPOT_FLAGS: disable-registration enable-login-with-password disable-email-verification disable-smtp enable-prepl-server enable-webhooks disable-telemetry\n      PENPOT_SECRET_KEY: ${PENPOT_SECRET_KEY}\n      PENPOT_PREPL_HOST: '0.0.0.0'\n      PENPOT_PUBLIC_URI: https://${DOMAIN_PENPOT}\n      PENPOT_DATABASE_URI: postgresql://penpot-postgres/${POSTGRES_DB}\n      PENPOT_DATABASE_USERNAME: ${POSTGRES_USER}\n      PENPOT_DATABASE_PASSWORD: ${POSTGRES_PASSWORD}\n      PENPOT_REDIS_URI: redis://penpot-redis/0\n      PENPOT_ASSETS_STORAGE_BACKEND: assets-fs\n      PENPOT_STORAGE_ASSETS_FS_DIRECTORY: /opt/data/assets\n      PENPOT_TELEMETRY_ENABLED: false\n\n  penpot-exporter:\n    image: penpotapp/exporter:latest\n    restart: unless-stopped\n    environment:\n      TZ: America/Guayaquil\n      PENPOT_PUBLIC_URI: https://${DOMAIN_PENPOT}\n      PENPOT_REDIS_URI: redis://penpot-redis/0\n\n  penpot-postgres:\n    image: postgres:15\n    restart: unless-stopped\n    volumes:\n      - ./db:/var/lib/postgresql/data\n    environment:\n      TZ: America/Guayaquil\n      POSTGRES_INITDB_ARGS: --data-checksums\n      POSTGRES_DB: ${POSTGRES_DB}\n      POSTGRES_USER: ${POSTGRES_USER}\n      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}\n\n  penpot-redis:\n    image: redis:7\n    restart: unless-stopped\n    environment:\n      TZ: America/Guayaquil\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre> <p>Note</p> <p>The container names actually matter in this case. It seems someplace the names might be hardcoded,and they really need to be named <code>penpot-backend</code> and <code>penpot-frontend</code>.</p>"},{"location":"servers/dev-ec-uio-1/services/development/penpot/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>POSTGRES_DB=\nPOSTGRES_USER=\nPOSTGRES_PASSWORD=\n\nPENPOT_SECRET_KEY=\n\nDOMAIN_PENPOT=\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/development/penpot/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/dev-ec-uio-1/services/development/penpot/#post-installation","title":"Post-Installation","text":"<p>You may have noticed the <code>docker-compose.yml</code> file has the env variable <code>PENPOT_FLAGS</code> for the containers <code>penpot-frontend</code> and <code>penpot-backend</code>. By default we prefer to keep user registration disabled. This means you should probably remove the <code>disable-registration</code> flag the first time you start the service, create your users, and then re-add the flag to disable future registrations.</p>"},{"location":"servers/dev-ec-uio-1/services/development/penpot/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/dev-ec-uio-1/services/development/sonarqube/","title":"Sonarqube","text":"<p>Sonarqube is a self-hosted code quality and static analysis tool.</p> <p>There is an official image for this service that we'll use: sonarqube.</p>"},{"location":"servers/dev-ec-uio-1/services/development/sonarqube/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/development/sonarqube\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/development/sonarqube/#docker-compose","title":"Docker Compose","text":"<p>Sonarqube will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: sonarqube:community\n    restart: unless-stopped\n    depends_on:\n      db:\n        condition: service_healthy\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - sonarqube\n    volumes:\n      - ./sonarqube/data:/opt/sonarqube/data\n      - ./sonarqube/extensions:/opt/sonarqube/extensions\n      - ./sonarqube/logs:/opt/sonarqube/logs\n      - ./sonarqube/temp:/opt/sonarqube/temp\n    environment:\n      TZ: America/Guayaquil\n      SONAR_JDBC_URL: jdbc:postgresql://db:5432/${POSTGRES_DATABASE}\n      SONAR_JDBC_USERNAME: ${POSTGRES_USER}\n      SONAR_JDBC_PASSWORD: ${POSTGRES_PASSWORD}\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.sonarqube.rule: Host(`${DOMAIN_SONARQUBE}`)\n      traefik.http.routers.sonarqube.entrypoints: public\n      traefik.http.routers.sonarqube.service: sonarqube@docker\n      traefik.http.services.sonarqube.loadbalancer.server.port: 9000\n\n  db:\n    image: postgres:17\n    restart: unless-stopped\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n    volumes:\n      - ./data:/var/lib/postgresql/data\n    environment:\n      TZ: America/Guayaquil\n      POSTGRES_DB: ${POSTGRES_DATABASE}\n      POSTGRES_USER: ${POSTGRES_USER}\n      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/development/sonarqube/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>POSTGRES_DATABASE=\nPOSTGRES_USER=\nPOSTGRES_PASSWORD=\n\nDOMAIN_SONARQUBE=\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/development/sonarqube/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/dev-ec-uio-1/services/development/sonarqube/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/dev-ec-uio-1/services/management/","title":"Initialization","text":"<p>All the services inside this section will be run through Docker. Since we'll use Docker Compose to execute the services, we'll create a folder on the main user's home folder dedicated to management services.</p> <pre><code>mkdir ~/services/management\n</code></pre> <p>For each service created, there will be a subfolder where a <code>docker-compose.yml</code> file will be located, alongside any data volumes required and even a <code>Dockerfile</code> if required.</p>"},{"location":"servers/dev-ec-uio-1/services/management/portainer-agent/","title":"Portainer Agent","text":"<p>Portainer is a web UI for Docker which allows us to have an insight on all the containers running on our server.</p> <p>The Portainer agent allows you to expose the machine's Docker management to another Portainer service hosted elsewhere. We're using the agent in this case to use the main Portainer service to manage this one.</p> <p>There is an official image for this service that we'll use: portainer/agent.</p>"},{"location":"servers/dev-ec-uio-1/services/management/portainer-agent/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/management/portainer-agent\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/management/portainer-agent/#docker-compose","title":"Docker Compose","text":"<p>Portainer Agent will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  agent:\n    image: portainer/agent:latest\n    restart: unless-stopped\n    ports:\n      - 9001:9001\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - /var/lib/docker/volumes:/var/lib/docker/volumes\n    environment:\n      TZ: America/Guayaquil\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/management/portainer-agent/#add-to-portainer","title":"Add to Portainer","text":"<p>In your main Portainer service,</p> <ol> <li>Head over to <code>Environments &gt; Add environment</code>.</li> <li>Pick <code>Docker Standalone</code> and click on <code>Start wizard</code>.</li> <li>Select <code>Agent</code>, set a <code>Name</code> for your agent and paste your server's address with <code>9001</code> as the port into <code>Environment address</code>.</li> <li>Finally, click <code>Connect</code>.</li> </ol> <p>And that's it, you can now manage your server's Docker services from your main Portainer service.</p>"},{"location":"servers/dev-ec-uio-1/services/management/portainer-agent/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/dev-ec-uio-1/services/networking/","title":"Initialization","text":"<p>All the services inside this section will be run through Docker. Since we'll use Docker Compose to execute the services, we'll create a folder on the main user's home folder dedicated to networking services.</p> <pre><code>mkdir ~/services/networking\n</code></pre> <p>For each service created, there will be a subfolder where a <code>docker-compose.yml</code> file will be located, alongside any data volumes required and even a <code>Dockerfile</code> if required.</p>"},{"location":"servers/dev-ec-uio-1/services/networking/cloudflared/","title":"Cloudflared","text":"<p>Warning</p> <p>You should set up Traefik first before setting this up.</p> <p>Cloudflared is a tunnel client that allows you to expose services in your network through a secure tunnel with Cloudflare.</p> <p>There is an official image for this service that we'll use: cloudflare/cloudflared.</p> <p>Note</p> <p>In order to use this service you need to have an active domain registered and configured to use Cloudflare as it's DNS zone manager.</p>"},{"location":"servers/dev-ec-uio-1/services/networking/cloudflared/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/networking/cloudflared\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/networking/cloudflared/#external-network","title":"External Network","text":"<p>Since this service needs to interoperate with another one, we'll need to have them inside the same network. Make sure to have created the <code>tunnel_external</code> network before defining the <code>docker-compose.yml</code> file. If you haven't created this network, you can do so with:</p> <pre><code>docker network create tunnel_external\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/networking/cloudflared/#creating-a-tunnel","title":"Creating a Tunnel","text":"<p>Before you can start the tunnel client, you need to acquire a token that will authenticate you to Cloudflare.</p> <p>First, visit the following page: https://one.dash.cloudflare.com and log in to your account.</p> <p>In the dashboard, click <code>Networks &gt; Tunnels</code> and click the <code>Create a tunnel</code> button.</p> <p></p> <p>Select <code>Cloudflared</code> and click <code>Next</code>.</p> <p></p> <p>Name your tunnel and click in <code>Save tunnel</code>.</p> <p></p> <p>Select <code>Docker</code> as the environment and copy the command shown below. You'll notice this command shows a token inside, you should copy this value and continue by running your Docker Compose stack with this value set as the container's <code>TUNNEL_TOKEN</code> environment variable.</p> <p>You should notice that when doing this, the webpage will update with the detected connector. If you see this, it means that your container is working perfectly. Finally click <code>Next</code>.</p> <p></p> <p>Next, create a temporary route. Cloudflare requires you to create one when creating the tunnel, however we'll remove it afterward because we do not need it for now.</p> <p>You can leave the subdomain as anything you want (just keep in mind that Cloudflare will automatically create a record with that subdomain name, so if you have another record with that name it may get replaced).</p> <p>Choose your domain to use, and leave the path empty. As the service you should choose <code>HTTP</code> as the type and set the <code>URL</code> to anything.</p> <p>Finally click <code>Save tunnel</code>.</p> <p></p> <p>You'll then be taken back to the tunnel dashboard. Select your newly created tunnel and click on the <code>Configure</code> button. You'll then see a tab that says <code>Public Hostname</code>, click on it, and you'll now see a list of your hostnames defined.</p> <p>And that's it. Whenever you need to add a new entry to the tunnel, just create a new hostname that points to <code>traefik:8000</code> and you're good to go.</p>"},{"location":"servers/dev-ec-uio-1/services/networking/cloudflared/#docker-compose","title":"Docker Compose","text":"<p>Cloudflared will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  tunnel:\n    image: cloudflare/cloudflared:latest\n    restart: unless-stopped\n    networks:\n      - default\n      - tunnel_external\n    command: tunnel run\n    environment:\n      TZ: America/Guayaquil\n      TUNNEL_TOKEN: ${CLOUDFLARE_TUNNEL_TOKEN}\n\nnetworks:\n  tunnel_external:\n    external: true\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/networking/cloudflared/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>CLOUDFLARE_TUNNEL_TOKEN=\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/networking/cloudflared/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/dev-ec-uio-1/services/networking/tailscale/","title":"Tailscale","text":"<p>Tailscale is a virtual LAN service, similar to Hamachi, that allows you to have your services exposed through a VPN.</p> <p>There is an official image for this service that we'll use: tailscale/tailscale.</p>"},{"location":"servers/dev-ec-uio-1/services/networking/tailscale/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/networking/tailscale\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/networking/tailscale/#getting-an-auth-key","title":"Getting an Auth Key","text":"<p>First head over to your Tailscale account's Dashboard &gt; Settings &gt; Keys and create <code>Generate auth key...</code>. You can name this key whatever you want and set the expiry to 1 day since we'll use it right off the bat.</p> <p>Once you generate it, copy it and save it somewhere, we'll use it in the docker-compose.yml file.</p>"},{"location":"servers/dev-ec-uio-1/services/networking/tailscale/#docker-compose","title":"Docker Compose","text":"<p>Tailscale will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  vpn:\n    image: tailscale/tailscale:latest\n    restart: unless-stopped\n    network_mode: host\n    cap_add:\n      - NET_ADMIN\n      - SYS_MODULE\n    volumes:\n      - /dev/net/tun:/dev/net/tun\n      - ./data:/var/lib/tailscale\n    environment:\n      TZ: America/Guayaquil\n      TS_AUTHKEY: ${TAILSCALE_AUTH_KEY}\n      TS_EXTRA_ARGS: --advertise-tags=tag:container --advertise-exit-node --accept-routes\n      TS_STATE_DIR: /var/lib/tailscale\n      TS_USERSPACE: false\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/networking/tailscale/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>TAILSCALE_AUTH_KEY=\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/networking/tailscale/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/dev-ec-uio-1/services/networking/traefik/","title":"Traefik","text":"<p>Traefik is a reverse proxy with a first-class integration with Docker.</p> <p>There is an official image for this service that we'll use: traefik.</p>"},{"location":"servers/dev-ec-uio-1/services/networking/traefik/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/networking/traefik\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/networking/traefik/#external-network","title":"External Network","text":"<p>Since this service needs to interoperate with another one, we'll need to have them inside the same network. Make sure to have created the <code>tunnel_external</code> and <code>proxy_external</code> networks before defining the <code>docker-compose.yml</code> file. If you haven't created these networks, you can do so with:</p> <pre><code>docker network create tunnel_external\ndocker network create proxy_external\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/networking/traefik/#configuration","title":"Configuration","text":"<p>Create a <code>traefik.yml</code> file with the following content:</p> <pre><code>global:\n  checkNewVersion: true\n\nlog:\n  level: DEBUG\n\napi:\n  insecure: true\n  dashboard: true\n\nproviders:\n  docker:\n    exposedByDefault: false\n    watch: true\n  file:\n    fileName: /etc/traefik/traefik.yaml\n    watch: true\n\nentryPoints:\n  public:\n    address: :8000\n  local-http:\n    address: :8020\n  local-https:\n    address: :8040\n\ncertificatesresolvers:\n  le:\n    acme:\n      dnschallenge:\n        provider: cloudflare\n        delaybeforecheck: 0\n        resolvers: 1.1.1.1\n      email: YOUR_EMAIL_HERE\n      storage: /letsencrypt/acme.json\n</code></pre> <p>Note</p> <p>Make sure to replace <code>YOUR_EMAIL_HERE</code> with your actual email.</p> <p>As a side note, we're using TLS in certain services that point to local IP addresses. I decided to go this route to keep using my own existing domain while keeping HTTPS active. We're using a DNS challenge which requires you to provide a Cloudflare API token with edit access for your DNS zones.</p> <p>If it does not apply to you, you may want to explore different challenges such as HTTP or TLS, or just serve your content through HTTP altogether.</p>"},{"location":"servers/dev-ec-uio-1/services/networking/traefik/#docker-compose","title":"Docker Compose","text":"<p>Traefik will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  proxy:\n    image: traefik:latest\n    restart: unless-stopped\n    extra_hosts:\n      - host.docker.internal:host-gateway\n    networks:\n      default:\n      tunnel_external:\n        aliases:\n          - traefik\n      proxy_external:\n        aliases:\n          - traefik\n    ports:\n      - 80:8020\n      - 443:8040\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n      - ./traefik.yml:/etc/traefik/traefik.yaml\n      - ./letsencrypt:/letsencrypt\n    environment:\n      TZ: America/Guayaquil\n      CF_DNS_API_TOKEN: ${CLOUDFLARE_API_TOKEN}\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.traefik.rule: Host(`${DOMAIN_TRAEFIK_LOCAL}`) || Host(`${DOMAIN_TRAEFIK_VPN}`)\n      traefik.http.routers.traefik.entrypoints: local-https\n      traefik.http.routers.traefik.tls: true\n      traefik.http.routers.traefik.tls.certresolver: le\n      traefik.http.routers.traefik.service: traefik@docker\n      traefik.http.services.traefik.loadbalancer.server.port: 8080\n\nnetworks:\n  proxy_external:\n    external: true\n  tunnel_external:\n    external: true\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/networking/traefik/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>CLOUDFLARE_API_TOKEN=\nDOMAIN_TRAEFIK_LOCAL=\nDOMAIN_TRAEFIK_VPN=\n</code></pre>"},{"location":"servers/dev-ec-uio-1/services/networking/traefik/#reverse-proxy","title":"Reverse Proxy","text":"<p>Traefik usually comes with a web dashboard for managing the resources exposed. Now, we're actually using it to expose its dashboard itself.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you don't want to use the proxy itself to expose its own dashboard, feel free to remove those labels and bind the dashboard port manually.</p>"},{"location":"servers/dev-ec-uio-1/services/networking/traefik/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/dev-ec-uio-1/services/networking/traefik/#further-reading","title":"Further Reading","text":"<p>This page just described the basic steps to follow to set up the reverse proxy. This is far from done, make sure you check out:</p> <ul> <li>How to expose web services via Cloudflare with cloudflared.</li> </ul>"},{"location":"servers/dev-eu-west-1/configuration/","title":"Introduction","text":"<p>This section contains details of the <code>dev-eu-west-1</code> server.</p> <p>This server is mostly used for development purposes.</p>"},{"location":"servers/dev-eu-west-1/configuration/#server-specs","title":"Server Specs","text":"<p>This server is a Hetzner CX-22 VPS with the following specs:</p> <ul> <li>OS: Ubuntu Server 24.04 LTS 64-bit</li> <li>CPU: 2 vCPU</li> <li>RAM: 4GB</li> <li>Storage: 40GB</li> </ul>"},{"location":"servers/dev-eu-west-1/configuration/custom-scripts/","title":"Custom Scripts","text":"<p>We will create some custom scripts that will help us with certain tasks. For this, we'll create the following folder:</p> <pre><code>mkdir -p /usr/local/bin\n</code></pre> <p>Then inside this folder we'll insert all the scripts that we'll add here. Make sure to make them executable with:</p> <pre><code>chmod +x &lt;file&gt;\n</code></pre>"},{"location":"servers/dev-eu-west-1/configuration/custom-scripts/#custom-docker-update","title":"<code>custom-docker-update</code>","text":"<p>We'll use this script to manually update docker compose containers.</p> <p>Usage</p> <p>Run <code>custom-docker-update</code> inside the folder where <code>docker-compose.yml</code> is located to update the container images used.</p> <pre><code>#!/bin/bash\n\necho \"Stopping containers...\"\ndocker compose stop\n\necho \"Removing containers...\"\ndocker compose rm -f\n\necho \"Pulling images...\"\ndocker compose pull\n\necho \"Restarting containers...\"\ndocker compose up -d\n</code></pre>"},{"location":"servers/dev-eu-west-1/configuration/custom-scripts/#custom-docker-restart","title":"<code>custom-docker-restart</code>","text":"<p>We'll use this script to completely restart docker compose containers, this removes the containers and restarts them.</p> <p>Usage</p> <p>Run <code>custom-docker-restart</code> inside the folder where <code>docker-compose.yml</code> is located to update the container images used.</p> <pre><code>#!/bin/bash\n\ndocker compose rm -fs &amp;&amp; docker compose up -d\n</code></pre>"},{"location":"servers/dev-eu-west-1/configuration/docker/","title":"Docker","text":"<p>All the services in the server will be run through Docker. We'll need to install it first.</p>"},{"location":"servers/dev-eu-west-1/configuration/docker/#installation","title":"Installation","text":"<p>To install Docker, simply run the following commands:</p> <pre><code>curl -fsSL https://get.docker.com -o get-docker.sh\nsudo sh ./get-docker.sh\n</code></pre> <p>Once it's done, you can remove the downloaded script:</p> <pre><code>rm get-docker.sh\n</code></pre>"},{"location":"servers/dev-eu-west-1/configuration/docker/#permissions","title":"Permissions","text":"<p>We'll add the required permissions for our user into the <code>docker</code> group.</p> <pre><code>sudo groupadd docker\nsudo gpasswd -a $USER docker\n</code></pre>"},{"location":"servers/dev-eu-west-1/configuration/installation/","title":"Installation","text":"<p>Since the VPS comes with the OS already installed, nothing else must be done.</p>"},{"location":"servers/dev-eu-west-1/configuration/installation/#post-installation","title":"Post-Installation","text":"<p>As a general rule of thumb, after installing the OS it is recommended to update the sources and packages:</p> <pre><code>sudo apt-get update &amp;&amp; sudo apt-get upgrade\n</code></pre>"},{"location":"servers/dev-eu-west-1/configuration/installation/#configuring-date-and-time","title":"Configuring Date and Time","text":"<p>By default, the OS will be installed with GMT+0 as the timezone. We'll change this to conform with our real timezone which is GMT-5.</p> <pre><code>sudo timedatectl set-timezone America/Guayaquil\n</code></pre>"},{"location":"servers/dev-eu-west-1/configuration/installation/#packages","title":"Packages","text":"<p>Here's a list of packages I like to have on the server.</p> <pre><code>sudo apt-get install openssh-server openssh-client net-tools neofetch nload progress nano htop git\n</code></pre>"},{"location":"servers/dev-eu-west-1/configuration/installation/#firewall","title":"Firewall","text":"<p>Hetzner comes with a free Firewall service that I recommend you use to only allow certain ports on certain interfaces.</p> <p>I won't go much into detail because the rules depend heavily on your use case, though I recommend you be as restrictive as possible when defining ports and interfaces.</p>"},{"location":"servers/dev-eu-west-1/configuration/installation/#git","title":"Git","text":"<p>By default, <code>git</code> does not have a credential store configured, so make sure you run the following command to allow git operations in protected repos:</p> <pre><code>git config --global credential.helper store\n</code></pre>"},{"location":"servers/dev-eu-west-1/services/","title":"Introduction","text":"<p>This section details the installation and configuration of all the services run by the server. All of these services are run through Docker, so make sure you have it set up before reading any further.</p>"},{"location":"servers/dev-eu-west-1/services/#configuration","title":"Configuration","text":"<p>All services will be located in the home folder. In order to be a bit more organized, we'll create a folder for everything:</p> <pre><code>mkdir ~/services\n</code></pre>"},{"location":"servers/dev-eu-west-1/services/analytics/","title":"Initialization","text":"<p>All the services inside this section will be run through Docker. Since we'll use Docker Compose to execute the services, we'll create a folder on the main user's home folder dedicated to analytics services.</p> <pre><code>mkdir ~/services/analytics\n</code></pre> <p>For each service created, there will be a subfolder where a <code>docker-compose.yml</code> file will be located, alongside any data volumes required and even a <code>Dockerfile</code> if required.</p>"},{"location":"servers/dev-eu-west-1/services/analytics/umami/","title":"Umami","text":"<p>Umami is a web analytics service.</p> <p>There is an official image for this service that we'll use: ghcr.io/umami-software.</p>"},{"location":"servers/dev-eu-west-1/services/analytics/umami/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/analytics/umami\n</code></pre>"},{"location":"servers/dev-eu-west-1/services/analytics/umami/#docker-compose","title":"Docker Compose","text":"<p>Umami will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: ghcr.io/umami-software/umami:postgresql-latest\n    restart: unless-stopped\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - umami\n    depends_on:\n      db:\n        condition: service_healthy\n    healthcheck:\n      test: [\"CMD-SHELL\", \"curl http://localhost:3000/api/heartbeat\"]\n      interval: 5s\n      timeout: 5s\n      retries: 5\n    environment:\n      TZ: America/Guayaquil\n      DATABASE_URL: postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DATABASE}\n      DATABASE_TYPE: postgresql\n      APP_SECRET: ${APP_SECRET}\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.umami-http.rule: Host(`${DOMAIN_UMAMI}`)\n      traefik.http.routers.umami-http.entrypoints: http\n      traefik.http.routers.umami-http.middlewares: umami-redirectscheme\n      traefik.http.routers.umami-http.service: umami@docker\n      traefik.http.routers.umami-https.rule: Host(`${DOMAIN_UMAMI}`)\n      traefik.http.routers.umami-https.entrypoints: https\n      traefik.http.routers.umami-https.service: umami@docker\n      traefik.http.routers.umami-https.middlewares: umami-headers\n      traefik.http.routers.umami-https.tls: true\n      traefik.http.routers.umami-https.tls.certresolver: le\n      traefik.http.services.umami.loadbalancer.server.port: 3000\n      traefik.http.middlewares.umami-redirectscheme.redirectscheme.scheme: https\n      traefik.http.middlewares.umami-redirectscheme.redirectscheme.permanent: true\n      traefik.http.middlewares.umami-headers.headers.customrequestheaders.X-Forwarded-Proto: https\n      traefik.http.middlewares.umami-headers.headers.customrequestheaders.Host: ${DOMAIN_UMAMI}\n\n  db:\n    image: postgres:15-alpine\n    restart: unless-stopped\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DATABASE}\"]\n      interval: 5s\n      timeout: 5s\n      retries: 5\n    volumes:\n      - ./data:/var/lib/postgresql/data\n    environment:\n      TZ: America/Guayaquil\n      POSTGRES_DB: ${POSTGRES_DATABASE}\n      POSTGRES_USER: ${POSTGRES_USER}\n      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre>"},{"location":"servers/dev-eu-west-1/services/analytics/umami/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>APP_SECRET=\nPOSTGRES_USER=\nPOSTGRES_PASSWORD=\nPOSTGRES_DATABASE=\nDOMAIN_UMAMI=\n</code></pre>"},{"location":"servers/dev-eu-west-1/services/analytics/umami/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/dev-eu-west-1/services/analytics/umami/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/dev-eu-west-1/services/analytics/umami/#post-configuration","title":"Post Configuration","text":"<p>The default credentials:</p> <ul> <li>User: <code>admin</code></li> <li>Password: <code>umami</code></li> </ul> <p>Make sure to change these credentials or remove them altogether.</p>"},{"location":"servers/dev-eu-west-1/services/development/","title":"Initialization","text":"<p>All the services inside this section will be run through Docker. Since we'll use Docker Compose to execute the services, we'll create a folder on the main user's home folder dedicated to development services.</p> <pre><code>mkdir ~/services/development\n</code></pre> <p>For each service created, there will be a subfolder where a <code>docker-compose.yml</code> file will be located, alongside any data volumes required and even a <code>Dockerfile</code> if required.</p>"},{"location":"servers/dev-eu-west-1/services/development/gitea/","title":"Gitea","text":"<p>Gitea is a self-hosted git server, useful for having a private VCS solution.</p> <p>There is an official image for this service that we'll use: gitea/gitea.</p>"},{"location":"servers/dev-eu-west-1/services/development/gitea/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/development/gitea\n</code></pre>"},{"location":"servers/dev-eu-west-1/services/development/gitea/#docker-compose","title":"Docker Compose","text":"<p>Gitea will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: gitea/gitea:latest\n    restart: unless-stopped\n    depends_on:\n      - db\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - gitea\n    volumes:\n      - ./data:/data\n    environment:\n      TZ: America/Guayaquil\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.gitea-http.rule: Host(`${DOMAIN_GITEA}`)\n      traefik.http.routers.gitea-http.entrypoints: http\n      traefik.http.routers.gitea-http.middlewares: gitea-redirectscheme\n      traefik.http.routers.gitea-http.service: gitea@docker\n      traefik.http.routers.gitea-https.rule: Host(`${DOMAIN_GITEA}`)\n      traefik.http.routers.gitea-https.entrypoints: https\n      traefik.http.routers.gitea-https.service: gitea@docker\n      traefik.http.routers.gitea-https.middlewares: gitea-headers\n      traefik.http.routers.gitea-https.tls: true\n      traefik.http.routers.gitea-https.tls.certresolver: le\n      traefik.http.services.gitea.loadbalancer.server.port: 3000\n      traefik.http.middlewares.gitea-redirectscheme.redirectscheme.scheme: https\n      traefik.http.middlewares.gitea-redirectscheme.redirectscheme.permanent: true\n      traefik.http.middlewares.gitea-headers.headers.customrequestheaders.X-Forwarded-Proto: https\n      traefik.http.middlewares.gitea-headers.headers.customrequestheaders.Host: ${DOMAIN_GITEA}\n\n  db:\n    image: postgres:14\n    restart: unless-stopped\n    volumes:\n      - ./db:/var/lib/postgresql/data\n    environment:\n      TZ: America/Guayaquil\n      POSTGRES_DB: ${POSTGRES_DB}\n      POSTGRES_USER: ${POSTGRES_USER}\n      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre>"},{"location":"servers/dev-eu-west-1/services/development/gitea/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>POSTGRES_DB=\nPOSTGRES_USER=\nPOSTGRES_PASSWORD=\n\nDOMAIN_GITEA=\n</code></pre>"},{"location":"servers/dev-eu-west-1/services/development/gitea/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/dev-eu-west-1/services/development/gitea/#post-installation","title":"Post-Installation","text":"<p>Once you have started the server once, edit the config file located inside the <code>data</code> volume:</p> <pre><code>nano data/gitea/conf/app.ini\n</code></pre> <p>And make sure to have the following lines:</p> <pre><code>[service]\nDISABLE_REGISTRATION = true\n</code></pre> <p>This will make sure that nobody else can register into your server without your knowledge.</p>"},{"location":"servers/dev-eu-west-1/services/development/gitea/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/dev-eu-west-1/services/management/","title":"Initialization","text":"<p>All the services inside this section will be run through Docker. Since we'll use Docker Compose to execute the services, we'll create a folder on the main user's home folder dedicated to management services.</p> <pre><code>mkdir ~/services/management\n</code></pre> <p>For each service created, there will be a subfolder where a <code>docker-compose.yml</code> file will be located, alongside any data volumes required and even a <code>Dockerfile</code> if required.</p>"},{"location":"servers/dev-eu-west-1/services/management/portainer-agent/","title":"Portainer Agent","text":"<p>Portainer is a web UI for Docker which allows us to have an insight on all the containers running on our server.</p> <p>The Portainer agent allows you to expose the machine's Docker management to another Portainer service hosted elsewhere. We're using the agent in this case to use the main Portainer service to manage this one.</p> <p>There is an official image for this service that we'll use: portainer/agent.</p>"},{"location":"servers/dev-eu-west-1/services/management/portainer-agent/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/management/portainer-agent\n</code></pre>"},{"location":"servers/dev-eu-west-1/services/management/portainer-agent/#docker-compose","title":"Docker Compose","text":"<p>Portainer Agent will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  agent:\n    image: portainer/agent:latest\n    restart: unless-stopped\n    ports:\n      - 9001:9001\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - /var/lib/docker/volumes:/var/lib/docker/volumes\n    environment:\n      TZ: America/Guayaquil\n</code></pre>"},{"location":"servers/dev-eu-west-1/services/management/portainer-agent/#add-to-portainer","title":"Add to Portainer","text":"<p>In your main Portainer service,</p> <ol> <li>Head over to <code>Environments &gt; Add environment</code>.</li> <li>Pick <code>Docker Standalone</code> and click on <code>Start wizard</code>.</li> <li>Select <code>Agent</code>, set a <code>Name</code> for your agent and paste your server's address with <code>9001</code> as the port into <code>Environment address</code>.</li> <li>Finally, click <code>Connect</code>.</li> </ol> <p>And that's it, you can now manage your server's Docker services from your main Portainer service.</p>"},{"location":"servers/dev-eu-west-1/services/management/portainer-agent/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/dev-eu-west-1/services/networking/","title":"Initialization","text":"<p>All the services inside this section will be run through Docker. Since we'll use Docker Compose to execute the services, we'll create a folder on the main user's home folder dedicated to networking services.</p> <pre><code>mkdir ~/services/networking\n</code></pre> <p>For each service created, there will be a subfolder where a <code>docker-compose.yml</code> file will be located, alongside any data volumes required and even a <code>Dockerfile</code> if required.</p>"},{"location":"servers/dev-eu-west-1/services/networking/tailscale/","title":"Tailscale","text":"<p>Tailscale is a virtual LAN service, similar to Hamachi, that allows you to have your services exposed through a VPN.</p> <p>There is an official image for this service that we'll use: tailscale/tailscale.</p>"},{"location":"servers/dev-eu-west-1/services/networking/tailscale/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/networking/tailscale\n</code></pre>"},{"location":"servers/dev-eu-west-1/services/networking/tailscale/#getting-an-auth-key","title":"Getting an Auth Key","text":"<p>First head over to your Tailscale account's Dashboard &gt; Settings &gt; Keys and create <code>Generate auth key...</code>. You can name this key whatever you want and set the expiry to 1 day since we'll use it right off the bat.</p> <p>Once you generate it, copy it and save it somewhere, we'll use it in the docker-compose.yml file.</p>"},{"location":"servers/dev-eu-west-1/services/networking/tailscale/#docker-compose","title":"Docker Compose","text":"<p>Tailscale will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  vpn:\n    image: tailscale/tailscale:latest\n    restart: unless-stopped\n    network_mode: host\n    cap_add:\n      - NET_ADMIN\n      - SYS_MODULE\n    volumes:\n      - /dev/net/tun:/dev/net/tun\n      - ./data:/var/lib/tailscale\n    environment:\n      TZ: America/Guayaquil\n      TS_AUTHKEY: ${TAILSCALE_AUTH_KEY}\n      TS_EXTRA_ARGS: --advertise-tags=tag:container --advertise-exit-node --accept-routes\n      TS_STATE_DIR: /var/lib/tailscale\n      TS_USERSPACE: false\n</code></pre>"},{"location":"servers/dev-eu-west-1/services/networking/tailscale/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>TAILSCALE_AUTH_KEY=\n</code></pre>"},{"location":"servers/dev-eu-west-1/services/networking/tailscale/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/dev-eu-west-1/services/networking/traefik/","title":"Traefik","text":"<p>Traefik is a reverse proxy with a first-class integration with Docker.</p> <p>There is an official image for this service that we'll use: traefik.</p>"},{"location":"servers/dev-eu-west-1/services/networking/traefik/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/networking/traefik\n</code></pre>"},{"location":"servers/dev-eu-west-1/services/networking/traefik/#external-network","title":"External Network","text":"<p>Since this service needs to interoperate with another one, we'll need to have them inside the same network. Make sure to have created the <code>proxy_external</code> network before defining the <code>docker-compose.yml</code> file. If you haven't created this network, you can do so with:</p> <pre><code>docker network create proxy_external\n</code></pre>"},{"location":"servers/dev-eu-west-1/services/networking/traefik/#configuration","title":"Configuration","text":"<p>Create a <code>traefik.yml</code> file with the following content:</p> <pre><code>global:\n  checkNewVersion: true\n\nlog:\n  level: DEBUG\n\napi:\n  insecure: true\n  dashboard: true\n\nproviders:\n  docker:\n    exposedByDefault: false\n    watch: true\n  file:\n    filename: /etc/traefik/traefik.yaml\n    watch: true\n\nentryPoints:\n  http:\n    address: :80\n  https:\n    address: :443\n\ncertificatesresolvers:\n  le:\n    acme:\n      httpChallenge:\n        entryPoint: http\n      email: YOUR_EMAIL_HERE\n      storage: /letsencrypt/acme.json\n</code></pre> <p>Note</p> <p>Make sure to replace <code>YOUR_EMAIL_HERE</code> with your actual email.</p>"},{"location":"servers/dev-eu-west-1/services/networking/traefik/#docker-compose","title":"Docker Compose","text":"<p>Traefik will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  proxy:\n    image: traefik:latest\n    restart: unless-stopped\n    extra_hosts:\n      - host.docker.internal:host-gateway\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - traefik\n    ports:\n      - 80:80\n      - 443:443\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n      - ./traefik.yml:/etc/traefik/traefik.yaml\n      - ./letsencrypt:/letsencrypt\n    environment:\n      TZ: America/Guayaquil\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.traefik-http.rule: Host(`${DOMAIN_TRAEFIK}`)\n      traefik.http.routers.traefik-http.entrypoints: http\n      traefik.http.routers.traefik-http.middlewares: traefik-redirectscheme\n      traefik.http.routers.traefik-http.service: traefik@docker\n      traefik.http.routers.traefik-https.rule: Host(`${DOMAIN_TRAEFIK}`)\n      traefik.http.routers.traefik-https.entrypoints: https\n      traefik.http.routers.traefik-https.service: traefik@docker\n      traefik.http.routers.traefik-https.tls: true\n      traefik.http.routers.traefik-https.tls.certresolver: le\n      traefik.http.services.traefik.loadbalancer.server.port: 8080\n      traefik.http.middlewares.traefik-redirectscheme.redirectscheme.scheme: https\n      traefik.http.middlewares.traefik-redirectscheme.redirectscheme.permanent: true\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre>"},{"location":"servers/dev-eu-west-1/services/networking/traefik/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DOMAIN_TRAEFIK=\n</code></pre>"},{"location":"servers/dev-eu-west-1/services/networking/traefik/#reverse-proxy","title":"Reverse Proxy","text":"<p>Traefik usually comes with a web dashboard for managing the resources exposed. Now, we're actually using it to expose its dashboard itself.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you don't want to use the proxy itself to expose its own dashboard, feel free to remove those labels and bind the dashboard port manually.</p>"},{"location":"servers/dev-eu-west-1/services/networking/traefik/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/dev-eu-west-1/services/observability/","title":"Initialization","text":"<p>All the services inside this section will be run through Docker. Since we'll use Docker Compose to execute the services, we'll create a folder on the main user's home folder dedicated to observability services.</p> <pre><code>mkdir ~/services/observability\n</code></pre> <p>For each service created, there will be a subfolder where a <code>docker-compose.yml</code> file will be located, alongside any data volumes required and even a <code>Dockerfile</code> if required.</p>"},{"location":"servers/dev-eu-west-1/services/observability/uptime-kuma/","title":"Uptime Kuma","text":"<p>Uptime Kuma is a status monitoring service that can expose a page with your services' uptime status.</p> <p>There is an official image for this service that we'll use: louislam/uptime-kuma.</p>"},{"location":"servers/dev-eu-west-1/services/observability/uptime-kuma/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/observability/uptime-kuma\n</code></pre>"},{"location":"servers/dev-eu-west-1/services/observability/uptime-kuma/#docker-compose","title":"Docker Compose","text":"<p>Uptime Kuma will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: louislam/uptime-kuma:latest\n    restart: unless-stopped\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - uptime-kuma\n    volumes:\n      - ./data:/app/data\n    environment:\n      TZ: America/Guayaquil\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.uptime-kuma-http.rule: Host(`${DOMAIN_UPTIME_KUMA}`)\n      traefik.http.routers.uptime-kuma-http.entrypoints: http\n      traefik.http.routers.uptime-kuma-http.middlewares: uptime-kuma-redirectscheme\n      traefik.http.routers.uptime-kuma-http.service: uptime-kuma@docker\n      traefik.http.routers.uptime-kuma-https.rule: Host(`${DOMAIN_UPTIME_KUMA}`)\n      traefik.http.routers.uptime-kuma-https.entrypoints: https\n      traefik.http.routers.uptime-kuma-https.service: uptime-kuma@docker\n      traefik.http.routers.uptime-kuma-https.middlewares: uptime-kuma-headers\n      traefik.http.routers.uptime-kuma-https.tls: true\n      traefik.http.routers.uptime-kuma-https.tls.certresolver: le\n      traefik.http.services.uptime-kuma.loadbalancer.server.port: 3001\n      traefik.http.middlewares.uptime-kuma-redirectscheme.redirectscheme.scheme: https\n      traefik.http.middlewares.uptime-kuma-redirectscheme.redirectscheme.permanent: true\n      traefik.http.middlewares.uptime-kuma-headers.headers.customrequestheaders.X-Forwarded-Proto: https\n      traefik.http.middlewares.uptime-kuma-headers.headers.customrequestheaders.Host: ${DOMAIN_UPTIME_KUMA}\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre>"},{"location":"servers/dev-eu-west-1/services/observability/uptime-kuma/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DOMAIN_UPTIME_KUMA=\n</code></pre>"},{"location":"servers/dev-eu-west-1/services/observability/uptime-kuma/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/dev-eu-west-1/services/observability/uptime-kuma/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/configuration/","title":"Introduction","text":"<p>This section contains details of the <code>misc-ec-uio-1</code> server.</p> <p>This server is mostly used for miscellaneous purposes.</p>"},{"location":"servers/misc-ec-uio-1/configuration/#server-specs","title":"Server Specs","text":"<p>This server is a self-built desktop with the following specs:</p> <ul> <li>OS: Ubuntu Server 22.04 LTS 64-bit</li> <li>CPU: Intel Core i3-4170 (4 Threads) @3.70GHz</li> <li>RAM: 2x8GB DDR3 @1600MHz (16GB - Dual Channel)</li> <li>Motherboard: Biostar H81MHV3</li> <li>Storage:<ol> <li>256GB Crucial BX500 SATA SSD</li> <li>2TB WD Green 5400RPM SATA HDD</li> <li>4TB WD Elements USB 3.0 HDD</li> <li>8TB Seagate USB 3.0 HDD</li> </ol> </li> </ul>"},{"location":"servers/misc-ec-uio-1/configuration/custom-scripts/","title":"Custom Scripts","text":"<p>We will create some custom scripts that will help us with certain tasks. For this, we'll create the following folder:</p> <pre><code>mkdir -p /usr/local/bin\n</code></pre> <p>Then inside this folder we'll insert all the scripts that we'll add here. Make sure to make them executable with:</p> <pre><code>chmod +x &lt;file&gt;\n</code></pre>"},{"location":"servers/misc-ec-uio-1/configuration/custom-scripts/#custom-docker-update","title":"<code>custom-docker-update</code>","text":"<p>We'll use this script to manually update docker compose containers.</p> <p>Usage</p> <p>Run <code>custom-docker-update</code> inside the folder where <code>docker-compose.yml</code> is located to update the container images used.</p> <pre><code>#!/bin/bash\n\necho \"Stopping containers...\"\ndocker compose stop\n\necho \"Removing containers...\"\ndocker compose rm -f\n\necho \"Pulling images...\"\ndocker compose pull\n\necho \"Restarting containers...\"\ndocker compose up -d\n</code></pre>"},{"location":"servers/misc-ec-uio-1/configuration/custom-scripts/#custom-docker-restart","title":"<code>custom-docker-restart</code>","text":"<p>We'll use this script to completely restart docker compose containers, this removes the containers and restarts them.</p> <p>Usage</p> <p>Run <code>custom-docker-restart</code> inside the folder where <code>docker-compose.yml</code> is located to update the container images used.</p> <pre><code>#!/bin/bash\n\ndocker compose rm -fs &amp;&amp; docker compose up -d\n</code></pre>"},{"location":"servers/misc-ec-uio-1/configuration/docker/","title":"Docker","text":"<p>All the services in the server will be run through Docker. We'll need to install it first.</p>"},{"location":"servers/misc-ec-uio-1/configuration/docker/#installation","title":"Installation","text":"<p>To install Docker, simply run the following commands:</p> <pre><code>curl -fsSL https://get.docker.com -o get-docker.sh\nsudo sh ./get-docker.sh\n</code></pre> <p>Once it's done, you can remove the downloaded script:</p> <pre><code>rm get-docker.sh\n</code></pre>"},{"location":"servers/misc-ec-uio-1/configuration/docker/#permissions","title":"Permissions","text":"<p>We'll add the required permissions for our user into the <code>docker</code> group.</p> <pre><code>sudo groupadd docker\nsudo gpasswd -a $USER docker\n</code></pre>"},{"location":"servers/misc-ec-uio-1/configuration/installation/","title":"Installation","text":"<p>The server will be running Ubuntu Server 22.04 LTS 64-bit in headless mode, meaning that no DE or WM will be used. The installation is quick and assisted by its own installation wizard. For better performance, you should install the minimal version which does not include any graphical interface other than the command line. Additionally, no packages were installed from the installation wizard.</p>"},{"location":"servers/misc-ec-uio-1/configuration/installation/#post-installation","title":"Post-Installation","text":"<p>As a general rule of thumb, after installing the OS it is recommended to update the sources and packages:</p> <pre><code>sudo apt-get update &amp;&amp; sudo apt-get upgrade\n</code></pre>"},{"location":"servers/misc-ec-uio-1/configuration/installation/#configuring-date-and-time","title":"Configuring Date and Time","text":"<p>By default, the OS will be installed with GMT+0 as the timezone. We'll change this to conform with our real timezone which is GMT-5.</p> <pre><code>sudo timedatectl set-timezone America/Guayaquil\n</code></pre>"},{"location":"servers/misc-ec-uio-1/configuration/installation/#packages","title":"Packages","text":"<p>Here's a list of packages I like to have on the server.</p> <pre><code>sudo apt-get install openssh-server openssh-client net-tools neofetch nload progress nano iputils-ping htop git speedtest-cli\n</code></pre>"},{"location":"servers/misc-ec-uio-1/configuration/installation/#firewall","title":"Firewall","text":"<p>UFW is a friendly frontend for iptables that makes it a lot easier to add connection rules to your firewall.</p> <p>We'll need to install UFW and set it up.</p> <pre><code>sudo apt-get install ufw\nsudo ufw default allow outgoing\nsudo ufw default deny incoming\nsudo ufw allow ssh\nsudo ufw enable\n</code></pre> <p>The commands should be pretty self-explanatory, these default the firewall to allow any connections going from the server to the Internet and deny any incoming connections from the Internet to the server.</p> <p>Make sure to also enable the <code>ssh</code> ports, otherwise you may get locked out of your system remotely and may need to physically configure the firewall to allow SSH connections.</p>"},{"location":"servers/misc-ec-uio-1/configuration/installation/#usage","title":"Usage","text":"<p>A very good command to check UFW's status (if it's enabled or disabled) and see all the custom rules added and active is:</p> <pre><code>sudo ufw status\n</code></pre> <p>You can add a new rule by using:</p> <pre><code>sudo ufw allow &lt;PORT_RANGE&gt;/&lt;PROTOCOL&gt;\n</code></pre>"},{"location":"servers/misc-ec-uio-1/configuration/installation/#git","title":"Git","text":"<p>By default, <code>git</code> does not have a credential store configured, so make sure you run the following command to allow git operations in protected repos:</p> <pre><code>git config --global credential.helper store\n</code></pre>"},{"location":"servers/misc-ec-uio-1/configuration/mounting-drives/","title":"Mounting Drives","text":"<p>This server has at least one USB hard drive that remains constantly connected. We need this drive to mount on system startup, for this, we'll need to set up the <code>fstab</code>.</p>"},{"location":"servers/misc-ec-uio-1/configuration/mounting-drives/#getting-drive-uuids","title":"Getting Drive UUIDs","text":"<p>In order to get the UUIDs of the drive in question, it is necessary to plug them in. Once this is done, execute the following:</p> <pre><code>lsblk -o NAME,FSTYPE,UUID\n</code></pre> <p>This will give an output similar to the following:</p> <pre><code>NAME   FSTYPE UUID\nsda           \n\u251c\u2500sda1 vfat   7811-FFBE\n\u2514\u2500sda2 ext4   3c98de9f-dc43-4e8d-85aa-767475ea957b\nsdb    ext4   418987da-2351-11e9-aec8-b8975ad7798b\n</code></pre> <p>If you cannot tell which drive is which, you can also run the following:</p> <pre><code>sudo fdisk -l\n</code></pre> <p>Which will give out an output similar to the following:</p> <pre><code>Disk /dev/sdb: 1.82 TiB, 2000398934016 bytes, 3907029168 sectors\nDisk model: Hitachi HUA72302\nUnits: sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\n\n\nDisk /dev/sda: 223.57 GiB, 240057409536 bytes, 468862128 sectors\nDisk model: CT240BX500SSD1  \nUnits: sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisklabel type: gpt\nDisk identifier: 18C45280-7C95-4D8C-8033-81277842D6FF\n\nDevice       Start       End   Sectors   Size Type\n/dev/sda1     2048   2203647   2201600     1G EFI System\n/dev/sda2  2203648 468858879 466655232 222.5G Linux filesystem\n</code></pre> <p>Notice the <code>Device</code> value for each, reference it with the output from the previous command, and you'll now be able to tell the identifier of the partitions you need.</p>"},{"location":"servers/misc-ec-uio-1/configuration/mounting-drives/#preparing-the-folders","title":"Preparing the Folders","text":"<p>We'll mount the hard drives in <code>/media</code>, for this we'll create the folders like so:</p> <pre><code>sudo mkdir /media/my_drive\n</code></pre> <p>You may also change the ownership on these folders if it causes any problem.</p> <pre><code>sudo chown -R 1000:1000 /media/my_drive\n</code></pre>"},{"location":"servers/misc-ec-uio-1/configuration/mounting-drives/#modifying-fstab","title":"Modifying <code>fstab</code>","text":"<p>Danger</p> <p>Make sure to have physical access to the server in case editing this file breaks your installation. If your file is not correct, the system will boot in safe-mode with SSH disabled.</p> <p>We'll modify the <code>/etc/fstab</code> file.</p> <pre><code>sudo nano /etc/fstab\n</code></pre> <p>And we'll add a new line for each hard drive with the following structure:</p> <pre><code>UUID=$UUID $DIR $FORMAT defaults 0 0\n</code></pre> <p>In our case, we'll add the following lines:</p> <pre><code>/dev/disk/by-uuid/98e05af0-fa9c-4952-a8d6-e09280626835 /media/my_drive ext4 defaults 0 0\n</code></pre> <p>Finally, reboot the server. The drive should now be automatically mounted.</p>"},{"location":"servers/misc-ec-uio-1/services/","title":"Introduction","text":"<p>This section details the installation and configuration of all the services run by the server. All of these services are run through Docker, so make sure you have it set up before reading any further.</p>"},{"location":"servers/misc-ec-uio-1/services/#configuration","title":"Configuration","text":"<p>All services will be located in the home folder. In order to be a bit more organized, we'll create a folder for everything:</p> <pre><code>mkdir ~/services\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/automation/","title":"Initialization","text":"<p>All the services inside this section will be run through Docker. Since we'll use Docker Compose to execute the services, we'll create a folder on the main user's home folder dedicated to automation services.</p> <pre><code>mkdir ~/services/automation\n</code></pre> <p>For each service created, there will be a subfolder where a <code>docker-compose.yml</code> file will be located, alongside any data volumes required and even a <code>Dockerfile</code> if required.</p>"},{"location":"servers/misc-ec-uio-1/services/automation/homebridge/","title":"Homebridge","text":"<p>Homebridge is an IoT bridge for HomeKit that brings support to iOS's HomeKit to smart home devices that originally do not provide support for it.</p> <p>There is an official image for this service that we'll use: homebridge/homebridge.</p>"},{"location":"servers/misc-ec-uio-1/services/automation/homebridge/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/automation/homebridge\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/automation/homebridge/#docker-compose","title":"Docker Compose","text":"<p>Homebridge will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: homebridge/homebridge:latest\n    restart: unless-stopped\n    network_mode: host\n    volumes:\n      - ./data:/homebridge\n    environment:\n      TZ: America/Guayaquil\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/automation/homebridge/#post-installation","title":"Post-Installation","text":"<p>We'll need to allow the service's port on our firewall.</p> <pre><code>sudo ufw allow 8581/tcp\nsudo ufw allow 51845/tcp\nsudo ufw allow 51845/udp\n</code></pre> <p>Note</p> <p>Make sure to check the <code>51845</code> port applies for you, I believe this port is chosen at random when setting-up Homebridge. You can check this by reading the output logs when setting-up this service.</p>"},{"location":"servers/misc-ec-uio-1/services/automation/homebridge/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/services/automation/n8n/","title":"n8n","text":"<p>n8n is a self-hosted node based automation to run run jobs based on triggers similarly to IFTTT.</p> <p>There is an official image for this service that we'll use: n8nio/n8n.</p>"},{"location":"servers/misc-ec-uio-1/services/automation/n8n/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/automation/n8n\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/automation/n8n/#docker-compose","title":"Docker Compose","text":"<p>n8n will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: n8nio/n8n:latest\n    restart: unless-stopped\n    depends_on:\n      - mongo\n      - redis\n      - rabbitmq\n    extra_hosts:\n      - host.docker.internal:host-gateway\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - n8n\n    volumes:\n      - ./data:/home/node/.n8n\n      - ./local:/home/node/host\n      - /media/sata_2tb/MVs:/home/node/binds/MVs\n    environment:\n      TZ: America/Guayaquil\n      GENERIC_TIMEZONE: America/Guayaquil\n      NODE_ENV: production\n      N8N_PORT: 5678\n      N8N_PROTOCOL: https\n      N8N_HOST: ${DOMAIN_N8N}\n      WEBHOOK_URL: https://${DOMAIN_N8N}/\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.n8n.rule: Host(`${DOMAIN_N8N}`)\n      traefik.http.routers.n8n.entrypoints: public\n      traefik.http.routers.n8n.service: n8n@docker\n      traefik.http.services.n8n.loadbalancer.server.port: 5678\n\n  mongo:\n    image: mongo:latest\n    restart: unless-stopped\n    volumes:\n      - ./mongo:/data/db\n    environment:\n      TZ: America/Guayaquil\n      MONGO_INITDB_ROOT_USERNAME: ${MONGO_USER}\n      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_PASSWORD}\n\n  mongo-express:\n    image: mongo-express:latest\n    restart: unless-stopped\n    depends_on:\n      - mongo\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - automation-mongo\n    environment:\n      TZ: America/Guayaquil\n      ME_CONFIG_OPTIONS_EDITORTHEME: ambiance\n      ME_CONFIG_BASICAUTH_USERNAME: ${MONGO_BASIC_AUTH_USER}\n      ME_CONFIG_BASICAUTH_PASSWORD: ${MONGO_BASIC_AUTH_PASSWORD}\n      ME_CONFIG_MONGODB_SERVER: mongo\n      ME_CONFIG_MONGODB_ADMINUSERNAME: ${MONGO_USER}\n      ME_CONFIG_MONGODB_ADMINPASSWORD: ${MONGO_PASSWORD}\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.automation-mongo.rule: Host(`${DOMAIN_MONGO_LOCAL}`) || Host(`${DOMAIN_MONGO_VPN}`)\n      traefik.http.routers.automation-mongo.entrypoints: local-https\n      traefik.http.routers.automation-mongo.tls: true\n      traefik.http.routers.automation-mongo.tls.certresolver: le\n      traefik.http.routers.automation-mongo.service: automation-mongo@docker\n      traefik.http.services.automation-mongo.loadbalancer.server.port: 8081\n\n  redis:\n    image: redis:latest\n    restart: unless-stopped\n    environment:\n      TZ: America/Guayaquil\n\n  redis-insight:\n    image: redis/redisinsight:latest\n    restart: unless-stopped\n    user: 1000:1000\n    depends_on:\n      - redis\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - automation-redis\n    volumes:\n      - ./redis-insight:/data\n    environment:\n      TZ: America/Guayaquil\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.automation-redis.rule: Host(`${DOMAIN_REDIS_LOCAL}`) || Host(`${DOMAIN_REDIS_VPN}`)\n      traefik.http.routers.automation-redis.entrypoints: local-https\n      traefik.http.routers.automation-redis.tls: true\n      traefik.http.routers.automation-redis.tls.certresolver: le\n      traefik.http.routers.automation-redis.service: automation-redis@docker\n      traefik.http.services.automation-redis.loadbalancer.server.port: 5540\n\n  rabbitmq:\n    image: rabbitmq:3-management\n    restart: unless-stopped\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - automation-rabbitmq\n    volumes:\n      - ./rabbitmq:/var/lib/rabbitmq\n    environment:\n      TZ: America/Guayaquil\n      RABBITMQ_DEFAULT_USER: ${RABBITMQ_USER}\n      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASSWORD}\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.automation-rabbit-mq.rule: Host(`${DOMAIN_RABBITMQ_LOCAL}`) || Host(`${DOMAIN_RABBITMQ_VPN}`)\n      traefik.http.routers.automation-rabbit-mq.entrypoints: local-https\n      traefik.http.routers.automation-rabbit-mq.tls: true\n      traefik.http.routers.automation-rabbit-mq.tls.certresolver: le\n      traefik.http.routers.automation-rabbit-mq.service: automation-rabbit-mq@docker\n      traefik.http.services.automation-rabbit-mq.loadbalancer.server.port: 15672\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/automation/n8n/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DOMAIN_N8N=\n\nDOMAIN_MONGO_LOCAL=\nDOMAIN_MONGO_VPN=\n\nDOMAIN_REDIS_LOCAL=\nDOMAIN_REDIS_VPN=\n\nDOMAIN_RABBITMQ_LOCAL=\nDOMAIN_RABBITMQ_VPN=\n\nMONGO_USER=\nMONGO_PASSWORD=\nMONGO_BASIC_AUTH_USER=\nMONGO_BASIC_AUTH_PASSWORD=\n\nRABBITMQ_USER=\nRABBITMQ_PASSWORD=\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/automation/n8n/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/misc-ec-uio-1/services/automation/n8n/#extras","title":"Extras","text":"<p>Technically to get n8n up and running you only need the <code>web</code> container. However, we've extended this stack with other services to use alongside n8n like:</p> <ul> <li>mongo as a database for data persistence.</li> <li>redis as a cache for caching certain operations to accelerate certain workflows.</li> <li>rabbitmq as a message queue for processing events for certain workflows.</li> </ul> <p>Each of these services come with web based dashboards to access their data from outside if needed.</p>"},{"location":"servers/misc-ec-uio-1/services/automation/n8n/#local-data","title":"Local Data","text":"<p>Additionally, you may have noticed the volumes in the <code>web</code> container. Only the first volume is required to keep n8n's data, the rest are extra volumes that we've included to interface with the host's local filesystem.</p>"},{"location":"servers/misc-ec-uio-1/services/automation/n8n/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/services/data/","title":"Initialization","text":"<p>All the services inside this section will be run through Docker. Since we'll use Docker Compose to execute the services, we'll create a folder on the main user's home folder dedicated to data services.</p> <pre><code>mkdir ~/services/data\n</code></pre> <p>For each service created, there will be a subfolder where a <code>docker-compose.yml</code> file will be located, alongside any data volumes required and even a <code>Dockerfile</code> if required.</p>"},{"location":"servers/misc-ec-uio-1/services/data/nextcloud/","title":"Nextcloud","text":"<p>Nextcloud is a self-hosted cloud data server, useful for keeping documents in your own server.</p> <p>There is an official image for this service that we'll use: nextcloud.</p>"},{"location":"servers/misc-ec-uio-1/services/data/nextcloud/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/data/nextcloud\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/data/nextcloud/#dockerfile","title":"Dockerfile","text":"<p>Despite the service having an official image available, it lacks a dependency necessary to allow for SMB shares as external storage.</p> <p>The following is the (tiny) <code>Dockerfile</code> that will be used for this service:</p> <pre><code>FROM nextcloud:stable\n\nRUN apt-get update &amp;&amp; apt-get install -y procps smbclient &amp;&amp; rm -rf /var/lib/apt/lists/*\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/data/nextcloud/#docker-compose","title":"Docker Compose","text":"<p>Nextcloud will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    build: .\n    restart: unless-stopped\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - nextcloud\n    depends_on:\n      - db\n    volumes:\n      - /media/sata_2tb/Nextcloud:/var/www/html\n    environment:\n      TZ: America/Guayaquil\n      MYSQL_DATABASE: ${MYSQL_DATABASE}\n      MYSQL_USER: ${MYSQL_USER}\n      MYSQL_PASSWORD: ${MYSQL_PASSWORD}\n      MYSQL_HOST: db\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.nextcloud.rule: Host(`${DOMAIN_NEXTCLOUD}`)\n      traefik.http.routers.nextcloud.entrypoints: public\n      traefik.http.routers.nextcloud.service: nextcloud@docker\n      traefik.http.services.nextcloud.loadbalancer.server.port: 80\n      traefik.http.middlewares.limit.buffering.memResponseBodyBytes: 2000000000\n\n  db:\n    image: mariadb:10.5\n    restart: unless-stopped\n    volumes:\n      - ./data:/var/lib/mysql\n    command: --transaction-isolation=READ-COMMITTED --binlog-format=ROW\n    environment:\n      TZ: America/Guayaquil\n      MYSQL_ROOT_PASSWORD: ${MYSQL_PASSWORD}\n      MYSQL_DATABASE: ${MYSQL_DATABASE}\n      MYSQL_USER: ${MYSQL_USER}\n      MYSQL_PASSWORD: ${MYSQL_PASSWORD}\n\n  cron:\n    image: nextcloud:stable\n    restart: unless-stopped\n    depends_on:\n      - web\n    volumes:\n      - /media/sata_2tb/Nextcloud:/var/www/html\n    entrypoint: /cron.sh\n    environment:\n      TZ: America/Guayaquil\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/data/nextcloud/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>MYSQL_DATABASE=\nMYSQL_USER=\nMYSQL_PASSWORD=\n\nDOMAIN_NEXTCLOUD=\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/data/nextcloud/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/misc-ec-uio-1/services/data/nextcloud/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/services/data/pairdrop/","title":"Pairdrop","text":"<p>Pairdrop is a peer-to-peer file sharing service that mimics Apple's AirDrop functionality through a web interface.</p> <p>There is no official image for this service, so we'll use ghcr.io/linuxserver/pairdrop.</p>"},{"location":"servers/misc-ec-uio-1/services/data/pairdrop/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/data/pairdrop\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/data/pairdrop/#docker-compose","title":"Docker Compose","text":"<p>Pairdrop will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: ghcr.io/linuxserver/pairdrop:latest\n    restart: unless-stopped\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - pairdrop\n    environment:\n      TZ: America/Guayaquil\n      PUID: 1000\n      PGID: 1000\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.pairdrop.rule: Host(`${DOMAIN_PAIRDROP_LOCAL}`) || Host(`${DOMAIN_PAIRDROP_VPN}`)\n      traefik.http.routers.pairdrop.entrypoints: local-https\n      traefik.http.routers.pairdrop.tls: true\n      traefik.http.routers.pairdrop.tls.certresolver: le\n      traefik.http.routers.pairdrop.service: pairdrop@docker\n      traefik.http.services.pairdrop.loadbalancer.server.port: 3000\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre> <p>Note</p> <p>In the case of the <code>PUID</code> and <code>PGID</code> environment variables, <code>1000</code> corresponds to the user's UID and GID respectively. You can find the values for your own user by running <code>id $whoami</code>.</p>"},{"location":"servers/misc-ec-uio-1/services/data/pairdrop/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DOMAIN_PAIRDROP_LOCAL=\nDOMAIN_PAIRDROP_VPN=\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/data/pairdrop/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/misc-ec-uio-1/services/data/pairdrop/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/services/data/rx-resume/","title":"Reactive Resume","text":"<p>Reactive Resume is a tool to easily create beautiful CVs.</p> <p>There is an official image for this service that we'll use: amruthpillai/reactive-resume.</p>"},{"location":"servers/misc-ec-uio-1/services/data/rx-resume/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/data/rxresume\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/data/rx-resume/#docker-compose","title":"Docker Compose","text":"<p>Reactive Resume will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  db:\n    image: postgres:15-alpine\n    restart: unless-stopped\n    volumes:\n      - ./data:/var/lib/postgresql/data\n    environment:\n      TZ: America/Guayaquil\n      POSTGRES_DB: ${POSTGRES_DATABASE}\n      POSTGRES_USER: ${POSTGRES_USER}\n      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}\n\n  api:\n    image: amruthpillai/reactive-resume:server-latest\n    restart: unless-stopped\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - rxresume_api\n    depends_on:\n      - db\n    environment:\n      TZ: America/Guayaquil\n      PUBLIC_URL: https://${DOMAIN_RXRESUME_WEB}\n      PUBLIC_SERVER_URL: https://${DOMAIN_RXRESUME_API}\n      POSTGRES_DB: ${POSTGRES_DATABASE}\n      POSTGRES_USER: ${POSTGRES_USER}\n      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}\n      SECRET_KEY: ${SECRET_KEY}\n      POSTGRES_HOST: db\n      POSTGRES_PORT: 5432\n      JWT_SECRET: ${JWT_SECRET}\n      JWT_EXPIRY_TIME: 604800\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.rxresume_api.rule: Host(`${DOMAIN_RXRESUME_API}`)\n      traefik.http.routers.rxresume_api.entrypoints: local-https\n      traefik.http.routers.rxresume_api.tls: true\n      traefik.http.routers.rxresume_api.tls.certresolver: le\n      traefik.http.routers.rxresume_api.service: rxresume_api@docker\n      traefik.http.services.rxresume_api.loadbalancer.server.port: 3100\n\n  web:\n    image: amruthpillai/reactive-resume:client-latest\n    restart: unless-stopped\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - rxresume_web\n    depends_on:\n      - api\n    environment:\n      TZ: America/Guayaquil\n      PUBLIC_URL: https://${DOMAIN_RXRESUME_WEB}\n      PUBLIC_SERVER_URL: https://${DOMAIN_RXRESUME_API}\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.rxresume_web.rule: Host(`${DOMAIN_RXRESUME_WEB}`)\n      traefik.http.routers.rxresume_web.entrypoints: local-https\n      traefik.http.routers.rxresume_web.tls: true\n      traefik.http.routers.rxresume_web.tls.certresolver: le\n      traefik.http.routers.rxresume_web.service: rxresume_web@docker\n      traefik.http.services.rxresume_web.loadbalancer.server.port: 3000\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/data/rx-resume/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>POSTGRES_DATABASE=\nPOSTGRES_USER=\nPOSTGRES_PASSWORD=\n\nSECRET_KEY=\nJWT_SECRET=\n\nDOMAIN_RXRESUME_WEB=\nDOMAIN_RXRESUME_API=\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/data/rx-resume/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/","title":"Initialization","text":"<p>All the services inside this section will be run through Docker. Since we'll use Docker Compose to execute the services, we'll create a folder on the main user's home folder dedicated to downloads services.</p> <pre><code>mkdir ~/services/downloads\n</code></pre> <p>For each service created, there will be a subfolder where a <code>docker-compose.yml</code> file will be located, alongside any data volumes required and even a <code>Dockerfile</code> if required.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/bazarr/","title":"Bazarr","text":"<p>Bazarr is an RSS downloader focused on subtitles.</p> <p>There is no official image for this service, so we'll use ghcr.io/linuxserver/bazarr.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/bazarr/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/downloads/bazarr\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/downloads/bazarr/#external-network","title":"External Network","text":"<p>Since this service needs to interoperate with another one, we'll need to have them inside the same network. Make sure to have created the <code>downloads_external</code> network before defining the <code>docker-compose.yml</code> file. If you haven't created this network, you can do so with:</p> <pre><code>docker network create downloads_external\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/downloads/bazarr/#docker-compose","title":"Docker Compose","text":"<p>Bazarr will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: ghcr.io/linuxserver/bazarr:latest\n    restart: unless-stopped\n    networks:\n      default:\n      downloads_external:\n      proxy_external:\n        aliases:\n          - bazarr\n    volumes:\n      - ./config:/config\n      - /media/usb_4tb:/media/usb_4tb\n      - /media/usb_8tb:/media/usb_8tb\n      - /media/sata_2tb/Downloads:/downloads\n    environment:\n      TZ: America/Guayaquil\n      PUID: 1000\n      PGID: 1000\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.bazarr.rule: Host(`${DOMAIN_BAZARR_LOCAL}`) || Host(`${DOMAIN_BAZARR_VPN}`)\n      traefik.http.routers.bazarr.entrypoints: local-https\n      traefik.http.routers.bazarr.tls: true\n      traefik.http.routers.bazarr.tls.certresolver: le\n      traefik.http.routers.bazarr.service: bazarr@docker\n      traefik.http.services.bazarr.loadbalancer.server.port: 6767\n\nnetworks:\n  downloads_external:\n    external: true\n  proxy_external:\n    external: true\n</code></pre> <p>Note</p> <p>In the case of the <code>PUID</code> and <code>PGID</code> environment variables, <code>1000</code> corresponds to the user's UID and GID respectively. You can find the values for your own user by running <code>id $whoami</code>.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/bazarr/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DOMAIN_BAZARR_LOCAL=\nDOMAIN_BAZARR_VPN=\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/downloads/bazarr/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/bazarr/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/jdownloader/","title":"JDownloader","text":"<p>JDownloader is a download client that makes downloading from direct links a breeze.</p> <p>There is no official image for this service, so we'll use jlesage/jdownloader-2.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/jdownloader/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/downloads/jdownloader\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/downloads/jdownloader/#external-network","title":"External Network","text":"<p>Since this service needs to interoperate with another one, we'll need to have them inside the same network. Make sure to have created the <code>downloads_external</code> network before defining the <code>docker-compose.yml</code> file. If you haven't created this network, you can do so with:</p> <pre><code>docker network create downloads_external\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/downloads/jdownloader/#docker-compose","title":"Docker Compose","text":"<p>JDownloader will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: jlesage/jdownloader-2:latest\n    restart: unless-stopped\n    networks:\n      default:\n      downloads_external:\n      proxy_external:\n        aliases:\n          - jdownloader\n    ports:\n      - 3129:3129\n    volumes:\n      - ./config:/config\n      - /media/sata_2tb/Downloads:/output\n    environment:\n      TZ: America/Guayaquil\n      USER_ID: 1000\n      GROUP_ID: 1000\n      VNC_PASSWORD: ${BASIC_AUTH_PASSWORD}\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.jdownloader.rule: Host(`${DOMAIN_JDOWNLOADER_LOCAL}`) || Host(`${DOMAIN_JDOWNLOADER_VPN}`)\n      traefik.http.routers.jdownloader.entrypoints: local-https\n      traefik.http.routers.jdownloader.tls: true\n      traefik.http.routers.jdownloader.tls.certresolver: le\n      traefik.http.routers.jdownloader.service: jdownloader@docker\n      traefik.http.services.jdownloader.loadbalancer.server.port: 5800\n\nnetworks:\n  downloads_external:\n    external: true\n  proxy_external:\n    external: true\n</code></pre> <p>Note</p> <p>In the case of the <code>USER_ID</code> and <code>GROUP_ID</code> environment variables, <code>1000</code> corresponds to the user's UID and GID respectively. You can find the values for your own user by running <code>id $whoami</code>.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/jdownloader/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DOMAIN_JDOWNLOADER_LOCAL=\nDOMAIN_JDOWNLOADER_VPN=\nBASIC_AUTH_PASSWORD=\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/downloads/jdownloader/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/jdownloader/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/overseerr/","title":"Overseerr","text":"<p>Overseer is a media request tracker, useful for when you share a Plex server or similar with family and friends.</p> <p>There is no official image for this service, so we'll use ghcr.io/linuxserver/overseerr.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/overseerr/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/downloads/overseerr\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/downloads/overseerr/#external-network","title":"External Network","text":"<p>Since this service needs to interoperate with another one, we'll need to have them inside the same network. Make sure to have created the <code>downloads_external</code> network before defining the <code>docker-compose.yml</code> file. If you haven't created this network, you can do so with:</p> <pre><code>docker network create downloads_external\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/downloads/overseerr/#docker-compose","title":"Docker Compose","text":"<p>Overseerr will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: ghcr.io/linuxserver/overseerr:latest\n    restart: unless-stopped\n    networks:\n      default:\n      downloads_external:\n      proxy_external:\n        aliases:\n          - overseerr\n    extra_hosts:\n      - host.docker.internal:host-gateway\n    volumes:\n      - ./config:/config\n    environment:\n      TZ: America/Guayaquil\n      PUID: 1000\n      PGID: 1000\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.overseerr.rule: Host(`${DOMAIN_OVERSEERR}`)\n      traefik.http.routers.overseerr.entrypoints: public\n      traefik.http.routers.overseerr.service: overseerr@docker\n      traefik.http.services.overseerr.loadbalancer.server.port: 5055\n\nnetworks:\n  downloads_external:\n    external: true\n  proxy_external:\n    external: true\n</code></pre> <p>Note</p> <p>In the case of the <code>PUID</code> and <code>PGID</code> environment variables, <code>1000</code> corresponds to the user's UID and GID respectively. You can find the values for your own user by running <code>id $whoami</code>.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/overseerr/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DOMAIN_OVERSEERR=\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/downloads/overseerr/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/overseerr/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/prowlarr/","title":"Prowlarr","text":"<p>Prowlarr is an indexer for -arr software.</p> <p>There is no official image for this service, so we'll use ghcr.io/linuxserver/prowlarr.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/prowlarr/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/downloads/prowlarr\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/downloads/prowlarr/#external-network","title":"External Network","text":"<p>Since this service needs to interoperate with another one, we'll need to have them inside the same network. Make sure to have created the <code>downloads_external</code> network before defining the <code>docker-compose.yml</code> file. If you haven't created this network, you can do so with:</p> <pre><code>docker network create downloads_external\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/downloads/prowlarr/#docker-compose","title":"Docker Compose","text":"<p>Prowlarr will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: ghcr.io/linuxserver/prowlarr:latest\n    restart: unless-stopped\n    networks:\n      default:\n      downloads_external:\n      proxy_external:\n        aliases:\n          - prowlarr\n    volumes:\n      - ./config:/config\n    environment:\n      TZ: America/Guayaquil\n      PUID: 1000\n      PGID: 1000\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.prowlarr.rule: Host(`${DOMAIN_PROWLARR_LOCAL}`) || Host(`${DOMAIN_PROWLARR_VPN}`)\n      traefik.http.routers.prowlarr.entrypoints: local-https\n      traefik.http.routers.prowlarr.tls: true\n      traefik.http.routers.prowlarr.tls.certresolver: le\n      traefik.http.routers.prowlarr.service: prowlarr@docker\n      traefik.http.services.prowlarr.loadbalancer.server.port: 9696\n\nnetworks:\n  downloads_external:\n    external: true\n  proxy_external:\n    external: true\n</code></pre> <p>Note</p> <p>In the case of the <code>PUID</code> and <code>PGID</code> environment variables, <code>1000</code> corresponds to the user's UID and GID respectively. You can find the values for your own user by running <code>id $whoami</code>.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/prowlarr/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DOMAIN_PROWLARR_LOCAL=\nDOMAIN_PROWLARR_VPN=\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/downloads/prowlarr/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/prowlarr/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/radarr/","title":"Radarr","text":"<p>Radarr is an RSS downloader focused on movies.</p> <p>There is no official image for this service, so we'll use ghcr.io/linuxserver/radarr.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/radarr/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/downloads/radarr\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/downloads/radarr/#external-network","title":"External Network","text":"<p>Since this service needs to interoperate with another one, we'll need to have them inside the same network. Make sure to have created the <code>downloads_external</code> network before defining the <code>docker-compose.yml</code> file. If you haven't created this network, you can do so with:</p> <pre><code>docker network create downloads_external\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/downloads/radarr/#docker-compose","title":"Docker Compose","text":"<p>Radarr will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: ghcr.io/linuxserver/radarr:latest\n    restart: unless-stopped\n    networks:\n      default:\n      downloads_external:\n      proxy_external:\n        aliases:\n          - radarr\n    volumes:\n      - ./config:/config\n      - /media/usb_4tb:/media/usb_4tb\n      - /media/usb_8tb:/media/usb_8tb\n      - /media/sata_2tb/Downloads:/downloads\n    environment:\n      TZ: America/Guayaquil\n      PUID: 1000\n      PGID: 1000\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.radarr.rule: Host(`${DOMAIN_RADARR_LOCAL}`) || Host(`${DOMAIN_RADARR_VPN}`)\n      traefik.http.routers.radarr.entrypoints: local-https\n      traefik.http.routers.radarr.tls: true\n      traefik.http.routers.radarr.tls.certresolver: le\n      traefik.http.routers.radarr.service: radarr@docker\n      traefik.http.services.radarr.loadbalancer.server.port: 7878\n\nnetworks:\n  downloads_external:\n    external: true\n  proxy_external:\n    external: true\n</code></pre> <p>Note</p> <p>In the case of the <code>PUID</code> and <code>PGID</code> environment variables, <code>1000</code> corresponds to the user's UID and GID respectively. You can find the values for your own user by running <code>id $whoami</code>.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/radarr/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DOMAIN_RADARR_LOCAL=\nDOMAIN_RADARR_VPN=\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/downloads/radarr/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/radarr/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/sonarr/","title":"Sonarr","text":"<p>Sonarr is an RSS downloader focused on TV Shows.</p> <p>There is no official image for this service, so we'll use ghcr.io/linuxserver/sonarr.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/sonarr/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/downloads/sonarr\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/downloads/sonarr/#external-network","title":"External Network","text":"<p>Since this service needs to interoperate with another one, we'll need to have them inside the same network. Make sure to have created the <code>downloads_external</code> network before defining the <code>docker-compose.yml</code> file. If you haven't created this network, you can do so with:</p> <pre><code>docker network create downloads_external\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/downloads/sonarr/#docker-compose","title":"Docker Compose","text":"<p>Sonarr will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: ghcr.io/linuxserver/sonarr:latest\n    restart: unless-stopped\n    networks:\n      default:\n      downloads_external:\n      proxy_external:\n        aliases:\n          - sonarr\n    volumes:\n      - ./config:/config\n      - /media/usb_4tb:/media/usb_4tb\n      - /media/usb_8tb:/media/usb_8tb\n      - /media/sata_2tb/Downloads:/downloads\n    environment:\n      TZ: America/Guayaquil\n      PUID: 1000\n      PGID: 1000\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.sonarr.rule: Host(`${DOMAIN_SONARR_LOCAL}`) || Host(`${DOMAIN_SONARR_VPN}`)\n      traefik.http.routers.sonarr.entrypoints: local-https\n      traefik.http.routers.sonarr.tls: true\n      traefik.http.routers.sonarr.tls.certresolver: le\n      traefik.http.routers.sonarr.service: sonarr@docker\n      traefik.http.services.sonarr.loadbalancer.server.port: 8989\n\nnetworks:\n  downloads_external:\n    external: true\n  proxy_external:\n    external: true\n</code></pre> <p>Note</p> <p>In the case of the <code>PUID</code> and <code>PGID</code> environment variables, <code>1000</code> corresponds to the user's UID and GID respectively. You can find the values for your own user by running <code>id $whoami</code>.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/sonarr/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DOMAIN_SONARR_LOCAL=\nDOMAIN_SONARR_VPN=\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/downloads/sonarr/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/sonarr/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/transmission/","title":"Transmission","text":"<p>Transmission is a BitTorrent client.</p> <p>There is no official image for this service, so we'll use ghcr.io/linuxserver/transmission.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/transmission/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/downloads/transmission\n</code></pre> <p>We'll need to download a GUI for Transmission manually. For this, inside the newly created folder, run the following commands:</p> <pre><code>curl -OL https://github.com/johman10/flood-for-transmission/releases/download/latest/flood-for-transmission.zip\nunzip flood-for-transmission.zip &amp;&amp; rm flood-for-transmission.zip\nmv flood-for-transmission web-ui\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/downloads/transmission/#external-network","title":"External Network","text":"<p>Since this service needs to interoperate with another one, we'll need to have them inside the same network. Make sure to have created the <code>downloads_external</code> network before defining the <code>docker-compose.yml</code> file. If you haven't created this network, you can do so with:</p> <pre><code>docker network create downloads_external\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/downloads/transmission/#docker-compose","title":"Docker Compose","text":"<p>Transmission will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: ghcr.io/linuxserver/transmission:latest\n    restart: unless-stopped\n    networks:\n      default:\n      downloads_external:\n      proxy_external:\n        aliases:\n          - transmission\n    ports:\n      - 51413:51413\n      - 51413:51413/udp\n    volumes:\n      - ./config:/config\n      - ./watch:/watch\n      - ./web-ui:/flood-for-transmission\n      - /media/sata_2tb/Downloads:/downloads\n    environment:\n      TZ: America/Guayaquil\n      TRANSMISSION_WEB_HOME: /flood-for-transmission/\n      USER: ${BASIC_AUTH_USER}\n      PASS: ${BASIC_AUTH_PASSWORD}\n      PUID: 1000\n      PGID: 1000\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.transmission.rule: Host(`${DOMAIN_TRANSMISSION_LOCAL}`) || Host(`${DOMAIN_TRANSMISSION_VPN}`)\n      traefik.http.routers.transmission.entrypoints: local-https\n      traefik.http.routers.transmission.tls: true\n      traefik.http.routers.transmission.tls.certresolver: le\n      traefik.http.routers.transmission.service: transmission@docker\n      traefik.http.services.transmission.loadbalancer.server.port: 9091\n\nnetworks:\n  downloads_external:\n    external: true\n  proxy_external:\n    external: true\n</code></pre> <p>Note</p> <p>In the case of the <code>PUID</code> and <code>PGID</code> environment variables, <code>1000</code> corresponds to the user's UID and GID respectively. You can find the values for your own user by running <code>id $whoami</code>.</p> <p>Note</p> <p>You may change the contents of <code>transmission-config/settings.json</code> as long as the container is stopped.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/transmission/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DOMAIN_TRANSMISSION_LOCAL=\nDOMAIN_TRANSMISSION_VPN=\nBASIC_AUTH_USER=\nBASIC_AUTH_PASSWORD=\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/downloads/transmission/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/misc-ec-uio-1/services/downloads/transmission/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/services/games/","title":"Initialization","text":"<p>All the services inside this section will be run through Docker. Since we'll use Docker Compose to execute the services, we'll create a folder on the main user's home folder dedicated to games services.</p> <pre><code>mkdir ~/services/games\n</code></pre> <p>For each service created, there will be a subfolder where a <code>docker-compose.yml</code> file will be located, alongside any data volumes required and even a <code>Dockerfile</code> if required.</p>"},{"location":"servers/misc-ec-uio-1/services/games/assetto-corsa/","title":"Assetto Corsa","text":"<p>Assetto Corsa is a realistic racing simulator.</p> <p>This game server has a community made server manager available on Docker Hub, however, I have made a small fork of this to update the source for SteamCMD since I've been having quite a lot of trouble getting it to work.</p> <p>This fork is available on ghcr.io/moonstar-x/assetto-server-managers, which is the image we'll use for this.</p>"},{"location":"servers/misc-ec-uio-1/services/games/assetto-corsa/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/games/assetto-corsa\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/games/assetto-corsa/#docker-compose","title":"Docker Compose","text":"<p>Assetto Corsa will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: ghcr.io/moonstar-x/assetto-server-manager:master\n    restart: unless-stopped\n    user: 1000:1000\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - assetto_corsa\n    ports:\n      - 9600:9600\n      - 9600:9600/udp\n      - 8081:8081\n    volumes:\n      - ./server:/home/assetto/server-manager/assetto\n      - ./data:/home/assetto/server-manager\n    environment:\n      TZ: America/Guayaquil\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.assetto_corsa.rule: Host(`${DOMAIN_ASSETTO_CORSA}`)\n      traefik.http.routers.assetto_corsa.entrypoints: public\n      traefik.http.routers.assetto_corsa.service: assetto_corsa@docker\n      traefik.http.services.assetto_corsa.loadbalancer.server.port: 8772\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre> <p>Warning</p> <p>Make sure to create the <code>data</code> and <code>server</code> folder before starting the container, otherwise you'll have some problems with the server data being saved.</p> <p>Note</p> <p>In the case of the <code>user</code> directive, <code>1000:1000</code> corresponds to the user's <code>UID:GID</code>. You can find the values for your own user by running <code>id $whoami</code>.</p>"},{"location":"servers/misc-ec-uio-1/services/games/assetto-corsa/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DOMAIN_ASSETTO_CORSA=\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/games/assetto-corsa/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/misc-ec-uio-1/services/games/assetto-corsa/#configuration","title":"Configuration","text":"<p>Create a config file inside <code>data/config.yml</code>:</p> <pre><code>nano data/config.yml\n</code></pre> <p>And paste the following:</p> <pre><code>steam:\n  username: STEAM_USER\n  password: STEAM_PASS\n  install_path: assetto\n  executable_path: acServer\n  force_update: false\n\nhttp:\n  hostname: 0.0.0.0:8772\n  session_key: RANDOMLY_GENERATE_THIS\n  server_manager_base_URL:\n  session_store_type: cookie\n  session_store_path: ''\n\n  tls:\n    enabled: false\n    cert_path: ''\n    key_path: ''\n\nmonitoring:\n  enabled: true\n\nstore:\n  type: boltdb\n  path: server_manager.db\n  shared_data_path:\n  scheduled_event_check_loop: 0s\n\naccounts:\n  admin_password_override:\n\nlive_map:\n  refresh_interval_ms: 500\n\nserver:\n  audit_logging: true\n  performance_mode: false\n  dont_open_browser: false\n  scan_content_folder_for_chanes: true\n  use_car_name_cache: true\n  persist_mid_session_results: false\n  plugins:\n\nchampionships:\n  recaptcha:\n    site_key:\n    secret_key:\n\nlua:\n  enabled: false\n</code></pre> <p>Note</p> <p>Make sure to replace <code>STEAM_USER</code> and <code>STEAM_PASS</code> with your steam account's information. I recommend you create a separate Steam account with Steam Guard disabled. You don't need an Assetto Corsa license to download the dedicated server.</p>"},{"location":"servers/misc-ec-uio-1/services/games/assetto-corsa/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/services/games/assetto-corsa/#joining-the-server","title":"Joining the Server","text":"<p>If you have set the server to be LAN only, you may join your server by going to the following URL:</p> <pre><code>https://acstuff.ru/s/q:race/online/join?ip=&lt;IP&gt;&amp;httpPort=8081\n</code></pre> <p>Make sure the clients have AC Content Manager to be able to access through that URL.</p>"},{"location":"servers/misc-ec-uio-1/services/games/romm/","title":"Romm","text":"<p>Romm is a frontend to manage and even play emulator roms.</p> <p>There is an official image for this service that we'll use: rommapp/romm.</p>"},{"location":"servers/misc-ec-uio-1/services/games/romm/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/games/romm\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/games/romm/#docker-compose","title":"Docker Compose","text":"<p>Romm will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: rommapp/romm:latest\n    restart: unless-stopped\n    depends_on:\n      - db\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - romm\n    volumes:\n      - ./resources:/romm/resources\n      - ./redis:/romm/redis-data\n      - /media/sata_2tb/Retroid:/romm/library\n      - ./assets:/romm/assets\n      - ./config:/romm/config\n    environment:\n      TZ: America/Guayaquil\n      DB_HOST: db\n      DB_NAME: ${MYSQL_DATABASE}\n      DB_USER: ${MYSQL_USER}\n      DB_PASSWD: ${MYSQL_PASSWORD}\n      IGDB_CLIENT_ID: ${IGDB_CLIENT_ID}\n      IGDB_CLIENT_SECRET: ${IGDB_CLIENT_SECRET}\n      ROMM_AUTH_SECRET_KEY: ${ROMM_AUTH_SECRET_KEY}\n      ROMM_AUTH_USERNAME: ${ROMM_AUTH_USERNAME}\n      ROMM_AUTH_PASSWORD: ${ROMM_AUTH_PASSWORD}\n      DISABLE_CSRF_PROTECTION: true\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.romm.rule: Host(`${DOMAIN_ROMM_LOCAL}`) || Host(`${DOMAIN_ROMM_VPN}`)\n      traefik.http.routers.romm.entrypoints: local-https\n      traefik.http.routers.romm.tls: true\n      traefik.http.routers.romm.tls.certresolver: le\n      traefik.http.routers.romm.service: romm@docker\n      traefik.http.services.romm.loadbalancer.server.port: 8080\n\n  db:\n    image: mariadb:10\n    restart: unless-stopped\n    volumes:\n      - ./data:/var/lib/mysql\n    environment:\n      TZ: America/Guayaquil\n      MYSQL_ROOT_PASSWORD: ${MYSQL_PASSWORD}\n      MYSQL_DATABASE: ${MYSQL_DATABASE}\n      MYSQL_USER: ${MYSQL_USER}\n      MYSQL_PASSWORD: ${MYSQL_PASSWORD}\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/games/romm/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>MYSQL_DATABASE=\nMYSQL_USER=\nMYSQL_PASSWORD=\n\nIGDB_CLIENT_ID=\nIGDB_CLIENT_SECRET=\nROMM_AUTH_SECRET_KEY=\nROMM_AUTH_USERNAME=\nROMM_AUTH_PASSWORD=\n\nDOMAIN_ROMM_LOCAL=\nDOMAIN_ROMM_VPN=\n</code></pre> <p>Note</p> <p>Make sure to change <code>AUTH_SECRET_KEY</code> to a custom secret value. You can generate this with <code>openssl rand -hex 32</code>. Also replace <code>AUTH_USERNAME</code> and <code>AUTH_PASSWORD</code> to something secret.</p> <p>Note</p> <p>Make sure to change <code>IGDB_CLIENT_ID</code> and <code>IGDB_CLIENT_SECRET</code> with a client ID and secret generated from twitch.tv.</p>"},{"location":"servers/misc-ec-uio-1/services/games/romm/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/misc-ec-uio-1/services/games/romm/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/services/games/teamspeak/","title":"TeamSpeak 3","text":"<p>TeamSpeak 3 is a gaming focused voice server.</p> <p>There is an official image for this service that we'll use: teamspeak.</p>"},{"location":"servers/misc-ec-uio-1/services/games/teamspeak/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/games/teamspeak\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/games/teamspeak/#docker-compose","title":"Docker Compose","text":"<p>TeamSpeak 3 will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  server:\n    image: teamspeak:latest\n    restart: unless-stopped\n    depends_on:\n      - db\n    ports:\n      - 9987:9987/udp\n      - 10011:10011\n      - 30033:30033\n    volumes:\n      - ./data:/var/ts3server\n    environment:\n      TZ: America/Guayaquil\n      TS3SERVER_DB_PLUGIN: ts3db_mariadb\n      TS3SERVER_DB_SQLCREATEPATH: create_mariadb\n      TS3SERVER_DB_HOST: db\n      TS3SERVER_DB_USER: root\n      TS3SERVER_DB_NAME: ${MYSQL_DATABASE}\n      TS3SERVER_DB_PASSWORD: ${MYSQL_PASSWORD}\n      TS3SERVER_DB_WAITUNTILREADY: 30\n      TS3SERVER_LICENSE: accept\n\n  db:\n    image: mariadb:10\n    restart: unless-stopped\n    volumes:\n      - ./db:/var/lib/mysql\n    environment:\n      TZ: America/Guayaquil\n      MYSQL_ROOT_PASSWORD: ${MYSQL_PASSWORD}\n      MYSQL_DATABASE: ${MYSQL_DATABASE}\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/games/teamspeak/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>MYSQL_DATABASE=\nMYSQL_PASSWORD=\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/games/teamspeak/#getting-server-auth-tokens","title":"Getting Server Auth Tokens","text":"<p>After the container has been created, check its logs and save the <code>serveradmin</code> login details. This is very important in case you get locked out of your server or if you need to change some settings through ServerQuery.</p> <p>Use:</p> <pre><code>docker compose logs server -f\n</code></pre> <p>You should also find here the privilege key to set up your user as the server administrator.</p>"},{"location":"servers/misc-ec-uio-1/services/games/teamspeak/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/services/management/","title":"Initialization","text":"<p>All the services inside this section will be run through Docker. Since we'll use Docker Compose to execute the services, we'll create a folder on the main user's home folder dedicated to management services.</p> <pre><code>mkdir ~/services/management\n</code></pre> <p>For each service created, there will be a subfolder where a <code>docker-compose.yml</code> file will be located, alongside any data volumes required and even a <code>Dockerfile</code> if required.</p>"},{"location":"servers/misc-ec-uio-1/services/management/portainer-agent/","title":"Portainer Agent","text":"<p>Portainer is a web UI for Docker which allows us to have an insight on all the containers running on our server.</p> <p>The Portainer agent allows you to expose the machine's Docker management to another Portainer service hosted elsewhere. We're using the agent in this case to use the main Portainer service to manage this one.</p> <p>There is an official image for this service that we'll use: portainer/agent.</p>"},{"location":"servers/misc-ec-uio-1/services/management/portainer-agent/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/management/portainer-agent\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/management/portainer-agent/#docker-compose","title":"Docker Compose","text":"<p>Portainer Agent will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  agent:\n    image: portainer/agent:latest\n    restart: unless-stopped\n    ports:\n      - 9001:9001\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - /var/lib/docker/volumes:/var/lib/docker/volumes\n    environment:\n      TZ: America/Guayaquil\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/management/portainer-agent/#add-to-portainer","title":"Add to Portainer","text":"<p>In your main Portainer service,</p> <ol> <li>Head over to <code>Environments &gt; Add environment</code>.</li> <li>Pick <code>Docker Standalone</code> and click on <code>Start wizard</code>.</li> <li>Select <code>Agent</code>, set a <code>Name</code> for your agent and paste your server's address with <code>9001</code> as the port into <code>Environment address</code>.</li> <li>Finally, click <code>Connect</code>.</li> </ol> <p>And that's it, you can now manage your server's Docker services from your main Portainer service.</p>"},{"location":"servers/misc-ec-uio-1/services/management/portainer-agent/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/services/media/","title":"Initialization","text":"<p>All the services inside this section will be run through Docker. Since we'll use Docker Compose to execute the services, we'll create a folder on the main user's home folder dedicated to media services.</p> <pre><code>mkdir ~/services/media\n</code></pre> <p>For each service created, there will be a subfolder where a <code>docker-compose.yml</code> file will be located, alongside any data volumes required and even a <code>Dockerfile</code> if required.</p>"},{"location":"servers/misc-ec-uio-1/services/media/jellyfin/","title":"Jellyfin","text":"<p>Jellyfin is an open source version of the famous media server Emby.</p> <p>There is an official image for this service that we'll use: jellyfin/jellyfin.</p>"},{"location":"servers/misc-ec-uio-1/services/media/jellyfin/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/media/jellyfin\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/media/jellyfin/#docker-compose","title":"Docker Compose","text":"<p>Jellyfin will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: jellyfin/jellyfin:latest\n    restart: unless-stopped\n    user: 1000:1000\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - jellyfin\n    volumes:\n      - ./config:/config\n      - ./cache:/cache\n      - /media/usb_4tb:/media/usb_4tb\n      - /media/usb_8tb:/media/usb_8tb\n      - /media/sata_2tb:/media/sata_2tb\n    environment:\n      TZ: America/Guayaquil\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.jellyfin-public.rule: Host(`${DOMAIN_JELLYFIN_PUBLIC}`)\n      traefik.http.routers.jellyfin-public.entrypoints: public\n      traefik.http.routers.jellyfin-public.service: jellyfin-mv@docker\n      traefik.http.routers.jellyfin-local.rule: Host(`${DOMAIN_JELLYFIN_LOCAL}`)\n      traefik.http.routers.jellyfin-local.entrypoints: local-https\n      traefik.http.routers.jellyfin-local.tls: true\n      traefik.http.routers.jellyfin-local.tls.certresolver: le\n      traefik.http.routers.jellyfin-local.service: jellyfin@docker\n      traefik.http.services.jellyfin.loadbalancer.server.port: 8096\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre> <p>Note</p> <p>In the case of the <code>user</code> directive, <code>1000:1000</code> corresponds to the user's <code>UID:GID</code>. You can find the values for your own user by running <code>id $whoami</code>.</p>"},{"location":"servers/misc-ec-uio-1/services/media/jellyfin/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DOMAIN_JELLYFIN_PUBLIC=\nDOMAIN_JELLYFIN_LOCAL=\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/media/jellyfin/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/misc-ec-uio-1/services/media/jellyfin/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/services/media/kavita/","title":"Kavita","text":"<p>Kavita is an eBook server for PDFs and EPUBs.</p> <p>There is an official image for this service that we'll use: jvmilazz0/kavita.</p>"},{"location":"servers/misc-ec-uio-1/services/media/kavita/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/media/kavita\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/media/kavita/#docker-compose","title":"Docker Compose","text":"<p>Kavita will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: jvmilazz0/kavita:latest\n    restart: unless-stopped\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - kavita\n    volumes:\n      - ./data:/kavita/config\n      - /media/sata_2tb/Books:/books\n    environment:\n      TZ: America/Guayaquil\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.kavita.rule: Host(`${DOMAIN_KAVITA}`)\n      traefik.http.routers.kavita.entrypoints: public\n      traefik.http.routers.kavita.service: kavita@docker\n      traefik.http.services.kavita.loadbalancer.server.port: 5000\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/media/kavita/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DOMAIN_KAVITA=\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/media/kavita/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/misc-ec-uio-1/services/media/kavita/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/services/media/plex/","title":"Plex","text":"<p>Plex is one of the most popular media server options out there.</p> <p>There is an official image for this service that we'll use: plexinc/pms-docker.</p>"},{"location":"servers/misc-ec-uio-1/services/media/plex/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/media/plex\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/media/plex/#docker-compose","title":"Docker Compose","text":"<p>Plex will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: plexinc/pms-docker:latest\n    restart: unless-stopped\n    network_mode: host\n    volumes:\n      - ./config:/config\n      - ./transcode:/transcode\n      - /media/usb_4tb:/media/usb_4tb\n      - /media/usb_8tb:/media/usb_8tb\n      - /media/sata_2tb:/media/sata_2tb\n    environment:\n      TZ: America/Guayaquil\n      PLEX_UID: 1000\n      PLEX_GID: 1000\n</code></pre> <p>Note</p> <p>In the case of the <code>PLEX_UID</code> and <code>PLEX_GID</code> environment variables, <code>1000</code> corresponds to the user's UID and GID respectively. You can find the values for your own user by running <code>id $whoami</code>.</p>"},{"location":"servers/misc-ec-uio-1/services/media/plex/#post-installation","title":"Post-Installation","text":"<p>We'll need to allow the service's port on our firewall.</p> <pre><code>sudo ufw allow 32400/tcp\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/media/plex/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/services/media/restreamer/","title":"Restreamer","text":"<p>Restreamer allows you to stream any type of media into multiple platforms simultaneously.</p> <p>There is an official image for this service that we'll use: datarhei/restreamer.</p>"},{"location":"servers/misc-ec-uio-1/services/media/restreamer/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/media/restreamer\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/media/restreamer/#docker-compose","title":"Docker Compose","text":"<p>Restreamer will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: datarhei/restreamer:latest\n    restart: unless-stopped\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - restreamer\n    ports:\n      - 1935:1935\n    volumes:\n      - ./config:/core/config\n      - ./data:/core/data\n    environment:\n      TZ: America/Guayaquil\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.restreamer.rule: Host(`${DOMAIN_RESTREAMER_LOCAL}`) || Host(`${DOMAIN_RESTREAMER_VPN}`)\n      traefik.http.routers.restreamer.entrypoints: local-https\n      traefik.http.routers.restreamer.tls: true\n      traefik.http.routers.restreamer.tls.certresolver: le\n      traefik.http.routers.restreamer.service: restreamer@docker\n      traefik.http.services.restreamer.loadbalancer.server.port: 8080\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/media/restreamer/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DOMAIN_RESTREAMER_LOCAL=\nDOMAIN_RESTREAMER_VPN=\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/media/restreamer/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/misc-ec-uio-1/services/media/restreamer/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/services/media/tautulli/","title":"Tautulli","text":"<p>Tautulli is a monitoring tool for Plex.</p> <p>There is an official image for this service that we'll use tautulli/tautulli.</p>"},{"location":"servers/misc-ec-uio-1/services/media/tautulli/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/media/tautulli\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/media/tautulli/#docker-compose","title":"Docker Compose","text":"<p>Tautulli will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: tautulli/tautulli:latest\n    restart: unless-stopped\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - tautulli\n    volumes:\n      - ./config:/config\n    environment:\n      TZ: America/Guayaquil\n      PUID: 1000\n      PGID: 1000\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.tautulli.rule: Host(`${DOMAIN_TAUTULLI}`)\n      traefik.http.routers.tautulli.entrypoints: public\n      traefik.http.routers.tautulli.service: tautulli@docker\n      traefik.http.services.tautulli.loadbalancer.server.port: 8181\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre> <p>Note</p> <p>In the case of the <code>PUID</code> and <code>PGID</code> environment variables, <code>1000</code> corresponds to the user's UID and GID respectively. You can find the values for your own user by running <code>id $whoami</code>.</p>"},{"location":"servers/misc-ec-uio-1/services/media/tautulli/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DOMAIN_TAUTULLI=\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/media/tautulli/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/misc-ec-uio-1/services/media/tautulli/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/services/networking/","title":"Initialization","text":"<p>All the services inside this section will be run through Docker. Since we'll use Docker Compose to execute the services, we'll create a folder on the main user's home folder dedicated to networking services.</p> <pre><code>mkdir ~/services/networking\n</code></pre> <p>For each service created, there will be a subfolder where a <code>docker-compose.yml</code> file will be located, alongside any data volumes required and even a <code>Dockerfile</code> if required.</p>"},{"location":"servers/misc-ec-uio-1/services/networking/cloudflared/","title":"Cloudflared","text":"<p>Warning</p> <p>You should set up Traefik first before setting this up.</p> <p>Cloudflared is a tunnel client that allows you to expose services in your network through a secure tunnel with Cloudflare.</p> <p>There is an official image for this service that we'll use: cloudflare/cloudflared.</p> <p>Note</p> <p>In order to use this service you need to have an active domain registered and configured to use Cloudflare as it's DNS zone manager.</p>"},{"location":"servers/misc-ec-uio-1/services/networking/cloudflared/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/networking/cloudflared\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/networking/cloudflared/#external-network","title":"External Network","text":"<p>Since this service needs to interoperate with another one, we'll need to have them inside the same network. Make sure to have created the <code>tunnel_external</code> network before defining the <code>docker-compose.yml</code> file. If you haven't created this network, you can do so with:</p> <pre><code>docker network create tunnel_external\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/networking/cloudflared/#creating-a-tunnel","title":"Creating a Tunnel","text":"<p>Before you can start the tunnel client, you need to acquire a token that will authenticate you to Cloudflare.</p> <p>First, visit the following page: https://one.dash.cloudflare.com and log in to your account.</p> <p>In the dashboard, click <code>Networks &gt; Tunnels</code> and click the <code>Create a tunnel</code> button.</p> <p></p> <p>Select <code>Cloudflared</code> and click <code>Next</code>.</p> <p></p> <p>Name your tunnel and click in <code>Save tunnel</code>.</p> <p></p> <p>Select <code>Docker</code> as the environment and copy the command shown below. You'll notice this command shows a token inside, you should copy this value and continue by running your Docker Compose stack with this value set as the container's <code>TUNNEL_TOKEN</code> environment variable.</p> <p>You should notice that when doing this, the webpage will update with the detected connector. If you see this, it means that your container is working perfectly. Finally click <code>Next</code>.</p> <p></p> <p>Next, create a temporary route. Cloudflare requires you to create one when creating the tunnel, however we'll remove it afterward because we do not need it for now.</p> <p>You can leave the subdomain as anything you want (just keep in mind that Cloudflare will automatically create a record with that subdomain name, so if you have another record with that name it may get replaced).</p> <p>Choose your domain to use, and leave the path empty. As the service you should choose <code>HTTP</code> as the type and set the <code>URL</code> to anything.</p> <p>Finally click <code>Save tunnel</code>.</p> <p></p> <p>You'll then be taken back to the tunnel dashboard. Select your newly created tunnel and click on the <code>Configure</code> button. You'll then see a tab that says <code>Public Hostname</code>, click on it, and you'll now see a list of your hostnames defined.</p> <p>And that's it. Whenever you need to add a new entry to the tunnel, just create a new hostname that points to <code>traefik:8000</code> and you're good to go.</p>"},{"location":"servers/misc-ec-uio-1/services/networking/cloudflared/#docker-compose","title":"Docker Compose","text":"<p>Cloudflared will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  tunnel:\n    image: cloudflare/cloudflared:latest\n    restart: unless-stopped\n    networks:\n      - default\n      - tunnel_external\n    command: tunnel run\n    environment:\n      TZ: America/Guayaquil\n      TUNNEL_TOKEN: ${CLOUDFLARE_TUNNEL_TOKEN}\n\nnetworks:\n  tunnel_external:\n    external: true\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/networking/cloudflared/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>CLOUDFLARE_TUNNEL_TOKEN=\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/networking/cloudflared/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/services/networking/samba/","title":"Samba","text":"<p>Samba lets your Linux based server share files and folders on a Windows File Sharing Workgroup using the same protocol (SMB/CIFS), this is pretty useful when you need to share files between computers on your network. This also helps to allow your files to be accessed through the Internet (although it should only be done through a VPN for security purposes).</p> <p>There is no official image for this service, so we'll use ghcr.io/servercontainers/samba.</p>"},{"location":"servers/misc-ec-uio-1/services/networking/samba/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/networking/samba\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/networking/samba/#docker-compose","title":"Docker Compose","text":"<p>Samba will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  server:\n    image: ghcr.io/servercontainers/samba:smbd-only-latest\n    restart: unless-stopped\n    network_mode: host\n    volumes:\n      - /media:/media\n      - ~/:/home\n    environment:\n      TZ: America/Guayaquil\n      SAMBA_CONF_LOG_LEVEL: 3\n      AVAHI_DISABLE: disabled\n      WSDD2_DISABLE: disabled\n      ACCOUNT_foo: ${ACCOUNT_FOO}\n      UID_foo: ${UID_FOO}\n      SAMBA_VOLUME_CONFIG_downloads: ${CONFIG_DOWNLOADS}\n</code></pre> <p>Feel free to edit the volumes and the volume configs at the bottom to your liking.</p>"},{"location":"servers/misc-ec-uio-1/services/networking/samba/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>ACCOUNT_FOO=\nUID_FOO=\n\nCONFIG_DOWNLOADS=\n</code></pre> <p>For the <code>ACCOUNT_FOO</code> variable, you will need to run the following command, which will generate a user hash that should be placed in the <code>.env</code> file.</p> <pre><code>docker run -it --rm ghcr.io/servercontainers/samba:smbd-only-latest create-hash.sh\n</code></pre> <p>This will generate a hash that you can use instead of adding your password in plaintext.</p> <p>The shares are defined through environment variables prefixed by <code>SAMBA_VOLUME_CONFIG</code>, you can create as many as you need. Same story for <code>ACCOUNT</code> and <code>UID</code> which are used to define accounts with access to the share and their respective UID.</p> <p>For the <code>CONFIG_*</code> variables, feel free to base yourself of the following example:</p> <pre><code>[downloads]\n  comment = Downloads directory.\n  path = /media/sata_2tb/Downloads\n  available = yes\n  read only = no\n  browsable = yes\n  writeable = yes\n  create mask = 0744\n  directory mask = 0755\n  force user = foo\n  force group = foo\n  public = no\n  guest ok = no\n</code></pre> <p>Note</p> <p>Make sure the wrap each block with double-quotes (<code>\"</code>) in the <code>.env</code> file to support multiline variables.</p>"},{"location":"servers/misc-ec-uio-1/services/networking/samba/#post-installation","title":"Post-Installation","text":"<p>We'll need to allow the service's port on our firewall.</p> <pre><code>sudo ufw allow 455/tcp\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/networking/samba/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/services/networking/tailscale/","title":"Tailscale","text":"<p>Tailscale is a virtual LAN service, similar to Hamachi, that allows you to have your services exposed through a VPN.</p> <p>There is an official image for this service that we'll use: tailscale/tailscale.</p>"},{"location":"servers/misc-ec-uio-1/services/networking/tailscale/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/networking/tailscale\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/networking/tailscale/#getting-an-auth-key","title":"Getting an Auth Key","text":"<p>First head over to your Tailscale account's Dashboard &gt; Settings &gt; Keys and create <code>Generate auth key...</code>. You can name this key whatever you want and set the expiry to 1 day since we'll use it right off the bat.</p> <p>Once you generate it, copy it and save it somewhere, we'll use it in the docker-compose.yml file.</p>"},{"location":"servers/misc-ec-uio-1/services/networking/tailscale/#docker-compose","title":"Docker Compose","text":"<p>Tailscale will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  vpn:\n    image: tailscale/tailscale:latest\n    restart: unless-stopped\n    network_mode: host\n    cap_add:\n      - NET_ADMIN\n      - SYS_MODULE\n    volumes:\n      - /dev/net/tun:/dev/net/tun\n      - ./data:/var/lib/tailscale\n    environment:\n      TZ: America/Guayaquil\n      TS_AUTHKEY: ${TAILSCALE_AUTH_KEY}\n      TS_EXTRA_ARGS: --advertise-tags=tag:container --advertise-exit-node --accept-routes\n      TS_STATE_DIR: /var/lib/tailscale\n      TS_USERSPACE: false\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/networking/tailscale/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>TAILSCALE_AUTH_KEY=\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/networking/tailscale/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/services/networking/traefik/","title":"Traefik","text":"<p>Traefik is a reverse proxy with a first-class integration with Docker.</p> <p>There is an official image for this service that we'll use: traefik.</p>"},{"location":"servers/misc-ec-uio-1/services/networking/traefik/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/networking/traefik\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/networking/traefik/#external-network","title":"External Network","text":"<p>Since this service needs to interoperate with another one, we'll need to have them inside the same network. Make sure to have created the <code>tunnel_external</code> and <code>proxy_external</code> networks before defining the <code>docker-compose.yml</code> file. If you haven't created these networks, you can do so with:</p> <pre><code>docker network create tunnel_external\ndocker network create proxy_external\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/networking/traefik/#configuration","title":"Configuration","text":"<p>Create a <code>traefik.yml</code> file with the following content:</p> <pre><code>global:\n  checkNewVersion: true\n\nlog:\n  level: DEBUG\n\napi:\n  insecure: true\n  dashboard: true\n\nproviders:\n  docker:\n    exposedByDefault: false\n    watch: true\n  file:\n    fileName: /etc/traefik/traefik.yaml\n    watch: true\n\nentryPoints:\n  public:\n    address: :8000\n  local-http:\n    address: :8020\n  local-https:\n    address: :8040\n\ncertificatesresolvers:\n  le:\n    acme:\n      dnschallenge:\n        provider: cloudflare\n        delaybeforecheck: 0\n        resolvers: 1.1.1.1\n      email: YOUR_EMAIL_HERE\n      storage: /letsencrypt/acme.json\n</code></pre> <p>Note</p> <p>Make sure to replace <code>YOUR_EMAIL_HERE</code> with your actual email.</p> <p>As a side note, we're using TLS in certain services that point to local IP addresses. I decided to go this route to keep using my own existing domain while keeping HTTPS active. We're using a DNS challenge which requires you to provide a Cloudflare API token with edit access for your DNS zones.</p> <p>If it does not apply to you, you may want to explore different challenges such as HTTP or TLS, or just serve your content through HTTP altogether.</p>"},{"location":"servers/misc-ec-uio-1/services/networking/traefik/#docker-compose","title":"Docker Compose","text":"<p>Traefik will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  proxy:\n    image: traefik:latest\n    restart: unless-stopped\n    extra_hosts:\n      - host.docker.internal:host-gateway\n    networks:\n      default:\n      tunnel_external:\n        aliases:\n          - traefik\n      proxy_external:\n        aliases:\n          - traefik\n    ports:\n      - 80:8020\n      - 443:8040\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n      - ./traefik.yml:/etc/traefik/traefik.yaml\n      - ./letsencrypt:/letsencrypt\n    environment:\n      TZ: America/Guayaquil\n      CF_DNS_API_TOKEN: ${CLOUDFLARE_API_TOKEN}\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.traefik.rule: Host(`${DOMAIN_TRAEFIK_LOCAL}`) || Host(`${DOMAIN_TRAEFIK_VPN}`)\n      traefik.http.routers.traefik.entrypoints: local-https\n      traefik.http.routers.traefik.tls: true\n      traefik.http.routers.traefik.tls.certresolver: le\n      traefik.http.routers.traefik.service: traefik@docker\n      traefik.http.services.traefik.loadbalancer.server.port: 8080\n\nnetworks:\n  proxy_external:\n    external: true\n  tunnel_external:\n    external: true\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/networking/traefik/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>CLOUDFLARE_API_TOKEN=\nDOMAIN_TRAEFIK_LOCAL=\nDOMAIN_TRAEFIK_VPN=\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/networking/traefik/#reverse-proxy","title":"Reverse Proxy","text":"<p>Traefik usually comes with a web dashboard for managing the resources exposed. Now, we're actually using it to expose its dashboard itself.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you don't want to use the proxy itself to expose its own dashboard, feel free to remove those labels and bind the dashboard port manually.</p>"},{"location":"servers/misc-ec-uio-1/services/networking/traefik/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-ec-uio-1/services/networking/traefik/#further-reading","title":"Further Reading","text":"<p>This page just described the basic steps to follow to set up the reverse proxy. This is far from done, make sure you check out:</p> <ul> <li>How to expose web services via Cloudflare with cloudflared.</li> </ul>"},{"location":"servers/misc-ec-uio-1/services/networking/zerotier/","title":"ZeroTier-One","text":"<p>ZeroTier-One is a virtual LAN service, similar to Hamachi, that allows you to have your services exposed through a VPN.</p> <p>There is an official image for this service that we'll use: zerotier/zerotier.</p>"},{"location":"servers/misc-ec-uio-1/services/networking/zerotier/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/networking/zerotier\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/networking/zerotier/#creating-a-network","title":"Creating a Network","text":"<p>To create a network, simply visit My ZeroTier, login to your account (or create one if needed) and simply click on the <code>Create Network</code> button. This will give you a Network ID (which you should keep since we'll need this). This Network ID is what you need to share with your friends so that they can connect to your network. If you leave the network settings to be private, you may need to manually authorize new members into the network.</p>"},{"location":"servers/misc-ec-uio-1/services/networking/zerotier/#docker-compose","title":"Docker Compose","text":"<p>ZeroTier-One will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  vpn:\n    image: zerotier/zerotier:latest\n    restart: unless-stopped\n    network_mode: host\n    cap_add:\n      - NET_ADMIN\n    devices:\n      - /dev/net/tun:/dev/net/tun\n    volumes:\n      - ./config/authtoken.secret:/var/lib/zerotier-one/authtoken.secret\n      - ./config/identity.public:/var/lib/zerotier-one/identity.public\n      - ./config/identity.secret:/var/lib/zerotier-one/identity.secret\n    command: ${NETWORK_ID}\n    environment:\n      TZ: America/Guayaquil\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/networking/zerotier/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>NETWORK_ID=\n</code></pre>"},{"location":"servers/misc-ec-uio-1/services/networking/zerotier/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-us-east-1/configuration/","title":"Introduction","text":"<p>This section contains details of the <code>misc-us-east-1</code> server.</p> <p>This server is mostly used for miscellaneous purposes.</p>"},{"location":"servers/misc-us-east-1/configuration/#server-specs","title":"Server Specs","text":"<p>This server is a Hetzner CPX-11 VPS with the following specs:</p> <ul> <li>OS: Ubuntu Server 22.04 LTS 64-bit</li> <li>CPU: 2 vCPU</li> <li>RAM: 2GB</li> <li>Storage: 40GB</li> </ul>"},{"location":"servers/misc-us-east-1/configuration/custom-scripts/","title":"Custom Scripts","text":"<p>We will create some custom scripts that will help us with certain tasks. For this, we'll create the following folder:</p> <pre><code>mkdir -p /usr/local/bin\n</code></pre> <p>Then inside this folder we'll insert all the scripts that we'll add here. Make sure to make them executable with:</p> <pre><code>chmod +x &lt;file&gt;\n</code></pre>"},{"location":"servers/misc-us-east-1/configuration/custom-scripts/#custom-docker-update","title":"<code>custom-docker-update</code>","text":"<p>We'll use this script to manually update docker compose containers.</p> <p>Usage</p> <p>Run <code>custom-docker-update</code> inside the folder where <code>docker-compose.yml</code> is located to update the container images used.</p> <pre><code>#!/bin/bash\n\necho \"Stopping containers...\"\ndocker compose stop\n\necho \"Removing containers...\"\ndocker compose rm -f\n\necho \"Pulling images...\"\ndocker compose pull\n\necho \"Restarting containers...\"\ndocker compose up -d\n</code></pre>"},{"location":"servers/misc-us-east-1/configuration/custom-scripts/#custom-docker-restart","title":"<code>custom-docker-restart</code>","text":"<p>We'll use this script to completely restart docker compose containers, this removes the containers and restarts them.</p> <p>Usage</p> <p>Run <code>custom-docker-restart</code> inside the folder where <code>docker-compose.yml</code> is located to update the container images used.</p> <pre><code>#!/bin/bash\n\ndocker compose rm -fs &amp;&amp; docker compose up -d\n</code></pre>"},{"location":"servers/misc-us-east-1/configuration/docker/","title":"Docker","text":"<p>All the services in the server will be run through Docker. We'll need to install it first.</p>"},{"location":"servers/misc-us-east-1/configuration/docker/#installation","title":"Installation","text":"<p>To install Docker, simply run the following commands:</p> <pre><code>curl -fsSL https://get.docker.com -o get-docker.sh\nsudo sh ./get-docker.sh\n</code></pre> <p>Once it's done, you can remove the downloaded script:</p> <pre><code>rm get-docker.sh\n</code></pre>"},{"location":"servers/misc-us-east-1/configuration/docker/#permissions","title":"Permissions","text":"<p>We'll add the required permissions for our user into the <code>docker</code> group.</p> <pre><code>sudo groupadd docker\nsudo gpasswd -a $USER docker\n</code></pre>"},{"location":"servers/misc-us-east-1/configuration/installation/","title":"Installation","text":"<p>Since the VPS comes with the OS already installed, nothing else must be done.</p>"},{"location":"servers/misc-us-east-1/configuration/installation/#post-installation","title":"Post-Installation","text":"<p>As a general rule of thumb, after installing the OS it is recommended to update the sources and packages:</p> <pre><code>sudo apt-get update &amp;&amp; sudo apt-get upgrade\n</code></pre>"},{"location":"servers/misc-us-east-1/configuration/installation/#configuring-date-and-time","title":"Configuring Date and Time","text":"<p>By default, the OS will be installed with GMT+0 as the timezone. We'll change this to conform with our real timezone which is GMT-5.</p> <pre><code>sudo timedatectl set-timezone America/Guayaquil\n</code></pre>"},{"location":"servers/misc-us-east-1/configuration/installation/#packages","title":"Packages","text":"<p>Here's a list of packages I like to have on the server.</p> <pre><code>sudo apt-get install openssh-server openssh-client net-tools neofetch nload progress nano htop git\n</code></pre>"},{"location":"servers/misc-us-east-1/configuration/installation/#firewall","title":"Firewall","text":"<p>Hetzner comes with a free Firewall service that I recommend you use to only allow certain ports on certain interfaces.</p> <p>I won't go much into detail because the rules depend heavily on your use case, though I recommend you be as restrictive as possible when defining ports and interfaces.</p>"},{"location":"servers/misc-us-east-1/configuration/installation/#git","title":"Git","text":"<p>By default, <code>git</code> does not have a credential store configured, so make sure you run the following command to allow git operations in protected repos:</p> <pre><code>git config --global credential.helper store\n</code></pre>"},{"location":"servers/misc-us-east-1/services/","title":"Introduction","text":"<p>This section details the installation and configuration of all the services run by the server. All of these services are run through Docker, so make sure you have it set up before reading any further.</p>"},{"location":"servers/misc-us-east-1/services/#configuration","title":"Configuration","text":"<p>All services will be located in the home folder. In order to be a bit more organized, we'll create a folder for everything:</p> <pre><code>mkdir ~/services\n</code></pre>"},{"location":"servers/misc-us-east-1/services/data/","title":"Initialization","text":"<p>All the services inside this section will be run through Docker. Since we'll use Docker Compose to execute the services, we'll create a folder on the main user's home folder dedicated to data services.</p> <pre><code>mkdir ~/services/data\n</code></pre> <p>For each service created, there will be a subfolder where a <code>docker-compose.yml</code> file will be located, alongside any data volumes required and even a <code>Dockerfile</code> if required.</p>"},{"location":"servers/misc-us-east-1/services/data/actual/","title":"Actual","text":"<p>Actual is a self-hosted budgeting application.</p> <p>There is an official image for this service that we'll use: actualbudget/actual-server.</p>"},{"location":"servers/misc-us-east-1/services/data/actual/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/data/actual\n</code></pre>"},{"location":"servers/misc-us-east-1/services/data/actual/#docker-compose","title":"Docker Compose","text":"<p>Actual will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: actualbudget/actual-server:latest\n    restart: unless-stopped\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - actual\n    volumes:\n      - ./data:/data\n    environment:\n      TZ: America/Guayaquil\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.actual.rule: Host(`${DOMAIN_ACTUAL}`)\n      traefik.http.routers.actual.entrypoints: tunnel\n      traefik.http.routers.actual.service: actual@docker\n      traefik.http.services.actual.loadbalancer.server.port: 5006\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre>"},{"location":"servers/misc-us-east-1/services/data/actual/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DOMAIN_ACTUAL=\n</code></pre>"},{"location":"servers/misc-us-east-1/services/data/actual/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/misc-us-east-1/services/data/actual/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-us-east-1/services/data/maybe/","title":"Maybe","text":"<p>Maybe is a self-hosted finance tracker application.</p> <p>There is an official image for this service that we'll use: ghcr.io/maybe-finance/maybe.</p>"},{"location":"servers/misc-us-east-1/services/data/maybe/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/data/maybe\n</code></pre>"},{"location":"servers/misc-us-east-1/services/data/maybe/#docker-compose","title":"Docker Compose","text":"<p>Maybe will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: ghcr.io/maybe-finance/maybe:stable\n    restart: unless-stopped\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - maybe\n    depends_on:\n      postgres:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n    volumes:\n      - ./storage:/rails/storage\n    environment:\n      TZ: America/Guayaquil\n      POSTGRES_USER: ${POSTGRES_USER}\n      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}\n      POSTGRES_DB: ${POSTGRES_DATABASE}\n      SECRET_KEY_BASE: ${SECRET_KEY_BASE}\n      SELF_HOSTED: true\n      RAILS_FORCE_SSL: false\n      RAILS_ASSUME_SSL: true\n      DB_HOST: postgres\n      DB_PORT: 5432\n      REDIS_URL: redis://redis:6379/1\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.maybe.rule: Host(`${DOMAIN_MAYBE}`)\n      traefik.http.routers.maybe.entrypoints: tunnel\n      traefik.http.routers.maybe.service: maybe@docker\n      traefik.http.services.maybe.loadbalancer.server.port: 3000\n      traefik.http.middlewares.maybe-headers.headers.customRequestHeaders.Host: '{host}'\n      traefik.http.middlewares.maybe-headers.headers.customRequestHeaders.X-Real-IP: '{clientip}'\n      traefik.http.middlewares.maybe-headers.headers.customRequestHeaders.X-Forwarded-For: '{clientip}'\n      traefik.http.middlewares.maybe-headers.headers.customRequestHeaders.X-Forwarded-Proto: '{scheme}'\n      traefik.http.routers.maybe.middlewares: 'maybe-headers'\n\n  worker:\n    image: ghcr.io/maybe-finance/maybe:latest\n    restart: unless-stopped\n    command: bundle exec sidekiq\n    depends_on:\n      redis:\n        condition: service_healthy\n    environment:\n      TZ: America/Guayaquil\n      POSTGRES_USER: ${POSTGRES_USER}\n      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}\n      POSTGRES_DB: ${POSTGRES_DATABASE}\n      SECRET_KEY_BASE: ${SECRET_KEY_BASE}\n      SELF_HOSTED: true\n      RAILS_FORCE_SSL: false\n      RAILS_ASSUME_SSL: true\n      DB_HOST: postgres\n      DB_PORT: 5432\n      REDIS_URL: redis://redis:6379/1\n\n  postgres:\n    image: postgres:15-alpine\n    restart: unless-stopped\n    healthcheck:\n      test: [ \"CMD-SHELL\", \"pg_isready -U $$POSTGRES_USER -d $$POSTGRES_DB\" ]\n      interval: 5s\n      timeout: 5s\n      retries: 5\n    volumes:\n      - ./data:/var/lib/postgresql/data\n    environment:\n      POSTGRES_DB: ${POSTGRES_DATABASE}\n      POSTGRES_USER: ${POSTGRES_USER}\n      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}\n\n  redis:\n    image: redis:7.4-rc2-alpine\n    restart: unless-stopped\n    healthcheck:\n      test: [ \"CMD\", \"redis-cli\", \"ping\" ]\n      interval: 5s\n      timeout: 5s\n      retries: 5\n    volumes:\n      - ./redis:/data\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre>"},{"location":"servers/misc-us-east-1/services/data/maybe/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>SECRET_KEY_BASE=\nPOSTGRES_USER=\nPOSTGRES_PASSWORD=\nPOSTGRES_DATABASE=\nDOMAIN_MAYBE=\n</code></pre>"},{"location":"servers/misc-us-east-1/services/data/maybe/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/misc-us-east-1/services/data/maybe/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-us-east-1/services/data/memos/","title":"Memos","text":"<p>Memos is a note-taking app that somewhat mimics what Twitter looks like. Perfect to use as a personal news feed.</p> <p>There is an official image for this service that we'll use: neosmemo/memos.</p>"},{"location":"servers/misc-us-east-1/services/data/memos/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/data/memos\n</code></pre>"},{"location":"servers/misc-us-east-1/services/data/memos/#docker-compose","title":"Docker Compose","text":"<p>Memos will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: neosmemo/memos:stable\n    restart: unless-stopped\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - memos\n    volumes:\n      - ./data:/var/opt/memos\n    environment:\n      TZ: America/Guayaquil\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.memos.rule: Host(`${DOMAIN_MEMOS}`)\n      traefik.http.routers.memos.entrypoints: tunnel\n      traefik.http.routers.memos.service: memos@docker\n      traefik.http.services.memos.loadbalancer.server.port: 5230\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre>"},{"location":"servers/misc-us-east-1/services/data/memos/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DOMAIN_MEMOS=\n</code></pre>"},{"location":"servers/misc-us-east-1/services/data/memos/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/misc-us-east-1/services/data/memos/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-us-east-1/services/data/wallos/","title":"Wallos","text":"<p>Wallos is a tracker for subscriptions. It serves as a way to take note of the subscriptions you have and get a monthly and yearly view of the total cost.</p> <p>There is an official image for this service that we'll use: bellamy/wallos.</p>"},{"location":"servers/misc-us-east-1/services/data/wallos/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/data/wallos\n</code></pre>"},{"location":"servers/misc-us-east-1/services/data/wallos/#docker-compose","title":"Docker Compose","text":"<p>Wallos will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: bellamy/wallos:latest\n    restart: unless-stopped\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - wallos\n    volumes:\n      - ./data:/var/www/html/db\n      - ./logos:/var/www/html/images/uploads/logos\n    environment:\n      TZ: America/Guayaquil\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.wallos.rule: Host(`${DOMAIN_WALLOS}`)\n      traefik.http.routers.wallos.entrypoints: tunnel\n      traefik.http.routers.wallos.service: wallos@docker\n      traefik.http.services.wallos.loadbalancer.server.port: 80\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre>"},{"location":"servers/misc-us-east-1/services/data/wallos/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DOMAIN_WALLOS=\n</code></pre>"},{"location":"servers/misc-us-east-1/services/data/wallos/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/misc-us-east-1/services/data/wallos/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-us-east-1/services/management/","title":"Initialization","text":"<p>All the services inside this section will be run through Docker. Since we'll use Docker Compose to execute the services, we'll create a folder on the main user's home folder dedicated to management services.</p> <pre><code>mkdir ~/services/management\n</code></pre> <p>For each service created, there will be a subfolder where a <code>docker-compose.yml</code> file will be located, alongside any data volumes required and even a <code>Dockerfile</code> if required.</p>"},{"location":"servers/misc-us-east-1/services/management/glance/","title":"Glance","text":"<p>Glance is a homepage builder with plenty of integrations.</p> <p>There is an official image for this service that we'll use: glanceapp/glance.</p>"},{"location":"servers/misc-us-east-1/services/management/glance/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/management/glance\n</code></pre>"},{"location":"servers/misc-us-east-1/services/management/glance/#docker-compose","title":"Docker Compose","text":"<p>Glance will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: glanceapp/glance:latest\n    restart: unless-stopped\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - glance\n    volumes:\n      - ./config:/app/config\n      - ./assets:/app/assets\n    environment:\n      TZ: America/Guayaquil\n      GITHUB_TOKEN: ${GITHUB_TOKEN}\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.glance.rule: Host(`${DOMAIN_GLANCE}`)\n      traefik.http.routers.glance.entrypoints: tunnel\n      traefik.http.routers.glance.service: glance@docker\n      traefik.http.services.glance.loadbalancer.server.port: 8080\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre> <p>Note</p> <p>You may not need to pass a <code>GITHUB_TOKEN</code> variable. I have added one because my configuration benefits from using it.</p>"},{"location":"servers/misc-us-east-1/services/management/glance/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>GITHUB_TOKEN=\n</code></pre>"},{"location":"servers/misc-us-east-1/services/management/glance/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/misc-us-east-1/services/management/glance/#post-configuration","title":"Post Configuration","text":"<p>To configure this, make sure to create a <code>config/glance.yml</code> file. Check out the documentation to see what you can add.</p>"},{"location":"servers/misc-us-east-1/services/management/glance/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-us-east-1/services/management/portainer/","title":"Portainer","text":"<p>Portainer is a web UI for Docker which allows us to have an insight on all the containers running on our server.</p> <p>There is an official image for this service that we'll use: portainer/portainer-ce.</p>"},{"location":"servers/misc-us-east-1/services/management/portainer/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/management/portainer\n</code></pre>"},{"location":"servers/misc-us-east-1/services/management/portainer/#docker-compose","title":"Docker Compose","text":"<p>Portainer will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: portainer/portainer-ce:latest\n    restart: unless-stopped\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - portainer\n    volumes:\n      - ./data:/data\n      - /var/run/docker.sock:/var/run/docker.sock\n    environment:\n      TZ: America/Guayaquil\n      TRUSTED_ORIGINS: ${DOMAIN_PORTAINER}\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.portainer.rule: Host(`${DOMAIN_PORTAINER}`)\n      traefik.http.routers.portainer.entrypoints: tunnel\n      traefik.http.routers.portainer.service: portainer@docker\n      traefik.http.services.portainer.loadbalancer.server.port: 9000\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre>"},{"location":"servers/misc-us-east-1/services/management/portainer/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DOMAIN_PORTAINER=\n</code></pre>"},{"location":"servers/misc-us-east-1/services/management/portainer/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/misc-us-east-1/services/management/portainer/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-us-east-1/services/management/rustdesk/","title":"Rustdesk","text":"<p>Rustdesk is an open source remote desktop software that allows us to self-host an ID and relay server to act as a middleman to connect two computers remotely.</p> <p>There is an official image for this service that we'll use: rustdesk/rustdesk-server.</p>"},{"location":"servers/misc-us-east-1/services/management/rustdesk/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/management/rustdesk\n</code></pre>"},{"location":"servers/misc-us-east-1/services/management/rustdesk/#docker-compose","title":"Docker Compose","text":"<p>Rustdesk will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  server:\n    image: rustdesk/rustdesk-server:latest\n    restart: unless-stopped\n    command: hbbs\n    ports:\n      - 21115:21115\n      - 21116:21116\n      - 21116:21116/udp\n      - 21118:21118\n    volumes:\n      - ./data:/root\n    environment:\n      TZ: America/Guayaquil\n\n  relay:\n    image: rustdesk/rustdesk-server:latest\n    restart: unless-stopped\n    command: hbbr\n    ports:\n      - 21117:21117\n      - 21119:21119\n    volumes:\n      - ./data:/root\n    environment:\n      TZ: America/Guayaquil\n</code></pre>"},{"location":"servers/misc-us-east-1/services/management/rustdesk/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-us-east-1/services/management/rustdesk/#post-installation","title":"Post Installation","text":"<p>Inside the <code>data</code> folder you'll find an <code>id_ed25519.pub</code> file. This is your public key. Every client that wants to connect to this ID and relay server must set this value.</p>"},{"location":"servers/misc-us-east-1/services/media/","title":"Initialization","text":"<p>All the services inside this section will be run through Docker. Since we'll use Docker Compose to execute the services, we'll create a folder on the main user's home folder dedicated to media services.</p> <pre><code>mkdir ~/services/media\n</code></pre> <p>For each service created, there will be a subfolder where a <code>docker-compose.yml</code> file will be located, alongside any data volumes required and even a <code>Dockerfile</code> if required.</p>"},{"location":"servers/misc-us-east-1/services/media/freshrss/","title":"FreshRSS","text":"<p>FreshRSS is an RSS feed reader.</p> <p>There is no official image for this service, so we'll use ghcr.io/linuxserver/freshrss.</p>"},{"location":"servers/misc-us-east-1/services/media/freshrss/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/media/freshrss\n</code></pre>"},{"location":"servers/misc-us-east-1/services/media/freshrss/#docker-compose","title":"Docker Compose","text":"<p>FreshRSS will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  web:\n    image: ghcr.io/linuxserver/freshrss:latest\n    restart: unless-stopped\n    networks:\n      default:\n      proxy_external:\n        aliases:\n          - freshrss\n    volumes:\n      - ./data:/config\n    environment:\n      TZ: America/Guayaquil\n      PUID: 1000\n      PGID: 1000\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.freshrss.rule: Host(`${DOMAIN_FRESHRSS}`)\n      traefik.http.routers.freshrss.entrypoints: tunnel\n      traefik.http.routers.freshrss.service: freshrss@docker\n      traefik.http.services.freshrss.loadbalancer.server.port: 80\n\nnetworks:\n  proxy_external:\n    external: true\n</code></pre> <p>Note</p> <p>In the case of the <code>PUID</code> and <code>PGID</code> environment variables, <code>1000</code> corresponds to the user's UID and GID respectively. You can find the values for your own user by running <code>id $whoami</code>.</p>"},{"location":"servers/misc-us-east-1/services/media/freshrss/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>DOMAIN_FRESHRSS=\n</code></pre>"},{"location":"servers/misc-us-east-1/services/media/freshrss/#reverse-proxy","title":"Reverse Proxy","text":"<p>This service is exposed by a reverse proxy. More specifically, it is using Traefik.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A directive to connect it to the <code>proxy_external</code> external network.</li> <li>A container alias for the <code>proxy_external</code> network.</li> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you're not using a reverse proxy, feel free to remove these from the <code>docker-compose.yml</code> file. Keep in mind you might need to bind the ports to connect to the service instead.</p>"},{"location":"servers/misc-us-east-1/services/media/freshrss/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-us-east-1/services/networking/","title":"Initialization","text":"<p>All the services inside this section will be run through Docker. Since we'll use Docker Compose to execute the services, we'll create a folder on the main user's home folder dedicated to networking services.</p> <pre><code>mkdir ~/services/networking\n</code></pre> <p>For each service created, there will be a subfolder where a <code>docker-compose.yml</code> file will be located, alongside any data volumes required and even a <code>Dockerfile</code> if required.</p>"},{"location":"servers/misc-us-east-1/services/networking/cloudflared/","title":"Cloudflared","text":"<p>Warning</p> <p>You should set up Traefik first before setting this up.</p> <p>Cloudflared is a tunnel client that allows you to expose services in your network through a secure tunnel with Cloudflare.</p> <p>There is an official image for this service that we'll use: cloudflare/cloudflared.</p> <p>Note</p> <p>In order to use this service you need to have an active domain registered and configured to use Cloudflare as it's DNS zone manager.</p>"},{"location":"servers/misc-us-east-1/services/networking/cloudflared/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/networking/cloudflared\n</code></pre>"},{"location":"servers/misc-us-east-1/services/networking/cloudflared/#external-network","title":"External Network","text":"<p>Since this service needs to interoperate with another one, we'll need to have them inside the same network. Make sure to have created the <code>tunnel_external</code> network before defining the <code>docker-compose.yml</code> file. If you haven't created this network, you can do so with:</p> <pre><code>docker network create tunnel_external\n</code></pre>"},{"location":"servers/misc-us-east-1/services/networking/cloudflared/#creating-a-tunnel","title":"Creating a Tunnel","text":"<p>Before you can start the tunnel client, you need to acquire a token that will authenticate you to Cloudflare.</p> <p>First, visit the following page: https://one.dash.cloudflare.com and log in to your account.</p> <p>In the dashboard, click <code>Networks &gt; Tunnels</code> and click the <code>Create a tunnel</code> button.</p> <p></p> <p>Select <code>Cloudflared</code> and click <code>Next</code>.</p> <p></p> <p>Name your tunnel and click in <code>Save tunnel</code>.</p> <p></p> <p>Select <code>Docker</code> as the environment and copy the command shown below. You'll notice this command shows a token inside, you should copy this value and continue by running your Docker Compose stack with this value set as the container's <code>TUNNEL_TOKEN</code> environment variable.</p> <p>You should notice that when doing this, the webpage will update with the detected connector. If you see this, it means that your container is working perfectly. Finally click <code>Next</code>.</p> <p></p> <p>Next, create a temporary route. Cloudflare requires you to create one when creating the tunnel, however we'll remove it afterward because we do not need it for now.</p> <p>You can leave the subdomain as anything you want (just keep in mind that Cloudflare will automatically create a record with that subdomain name, so if you have another record with that name it may get replaced).</p> <p>Choose your domain to use, and leave the path empty. As the service you should choose <code>HTTP</code> as the type and set the <code>URL</code> to anything.</p> <p>Finally click <code>Save tunnel</code>.</p> <p></p> <p>You'll then be taken back to the tunnel dashboard. Select your newly created tunnel and click on the <code>Configure</code> button. You'll then see a tab that says <code>Public Hostname</code>, click on it, and you'll now see a list of your hostnames defined.</p> <p>And that's it. Whenever you need to add a new entry to the tunnel, just create a new hostname that points to <code>traefik:8000</code> and you're good to go.</p>"},{"location":"servers/misc-us-east-1/services/networking/cloudflared/#docker-compose","title":"Docker Compose","text":"<p>Cloudflared will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  tunnel:\n    image: cloudflare/cloudflared:latest\n    restart: unless-stopped\n    networks:\n      - default\n      - tunnel_external\n    command: tunnel run\n    environment:\n      TZ: America/Guayaquil\n      TUNNEL_TOKEN: ${CLOUDFLARE_TUNNEL_TOKEN}\n\nnetworks:\n  tunnel_external:\n    external: true\n</code></pre>"},{"location":"servers/misc-us-east-1/services/networking/cloudflared/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>CLOUDFLARE_TUNNEL_TOKEN=\n</code></pre>"},{"location":"servers/misc-us-east-1/services/networking/cloudflared/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-us-east-1/services/networking/tailscale/","title":"Tailscale","text":"<p>Tailscale is a virtual LAN service, similar to Hamachi, that allows you to have your services exposed through a VPN.</p> <p>There is an official image for this service that we'll use: tailscale/tailscale.</p>"},{"location":"servers/misc-us-east-1/services/networking/tailscale/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/networking/tailscale\n</code></pre>"},{"location":"servers/misc-us-east-1/services/networking/tailscale/#getting-an-auth-key","title":"Getting an Auth Key","text":"<p>First head over to your Tailscale account's Dashboard &gt; Settings &gt; Keys and create <code>Generate auth key...</code>. You can name this key whatever you want and set the expiry to 1 day since we'll use it right off the bat.</p> <p>Once you generate it, copy it and save it somewhere, we'll use it in the docker-compose.yml file.</p>"},{"location":"servers/misc-us-east-1/services/networking/tailscale/#docker-compose","title":"Docker Compose","text":"<p>Tailscale will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  vpn:\n    image: tailscale/tailscale:latest\n    restart: unless-stopped\n    network_mode: host\n    cap_add:\n      - NET_ADMIN\n      - SYS_MODULE\n    volumes:\n      - /dev/net/tun:/dev/net/tun\n      - ./data:/var/lib/tailscale\n    environment:\n      TZ: America/Guayaquil\n      TS_AUTHKEY: ${TAILSCALE_AUTH_KEY}\n      TS_EXTRA_ARGS: --advertise-tags=tag:container --advertise-exit-node --accept-routes\n      TS_STATE_DIR: /var/lib/tailscale\n      TS_USERSPACE: false\n</code></pre>"},{"location":"servers/misc-us-east-1/services/networking/tailscale/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>TAILSCALE_AUTH_KEY=\n</code></pre>"},{"location":"servers/misc-us-east-1/services/networking/tailscale/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-us-east-1/services/networking/traefik/","title":"Traefik","text":"<p>Traefik is a reverse proxy with a first-class integration with Docker.</p> <p>There is an official image for this service that we'll use: traefik.</p>"},{"location":"servers/misc-us-east-1/services/networking/traefik/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/networking/traefik\n</code></pre>"},{"location":"servers/misc-us-east-1/services/networking/traefik/#external-network","title":"External Network","text":"<p>Since this service needs to interoperate with another one, we'll need to have them inside the same network. Make sure to have created the <code>tunnel_external</code> and <code>proxy_external</code> networks before defining the <code>docker-compose.yml</code> file. If you haven't created these networks, you can do so with:</p> <pre><code>docker network create tunnel_external\ndocker network create proxy_external\n</code></pre>"},{"location":"servers/misc-us-east-1/services/networking/traefik/#configuration","title":"Configuration","text":"<p>Create a <code>traefik.yml</code> file with the following content:</p> <pre><code>global:\n  checkNewVersion: true\n\nlog:\n  level: DEBUG\n\napi:\n  insecure: true\n  dashboard: true\n\nproviders:\n  docker:\n    exposedByDefault: false\n    watch: true\n  file:\n    fileName: /etc/traefik/traefik.yaml\n    watch: true\n\nentryPoints:\n  tunnel:\n    address: :8000\n  direct:\n    address: :8020\n\ncertificatesresolvers:\n  le:\n    acme:\n      dnschallenge:\n        provider: cloudflare\n        delaybeforecheck: 0\n        resolvers: 1.1.1.1\n      email: YOUR_EMAIL_HERE\n      storage: /letsencrypt/acme.json\n</code></pre> <p>Note</p> <p>Make sure to replace <code>YOUR_EMAIL_HERE</code> with your actual email.</p> <p>As a side note, we're using TLS in certain services that point to local IP addresses. I decided to go this route to keep using my own existing domain while keeping HTTPS active. We're using a DNS challenge which requires you to provide a Cloudflare API token with edit access for your DNS zones.</p> <p>If it does not apply to you, you may want to explore different challenges such as HTTP or TLS, or just serve your content through HTTP altogether.</p>"},{"location":"servers/misc-us-east-1/services/networking/traefik/#docker-compose","title":"Docker Compose","text":"<p>Traefik will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  proxy:\n    image: traefik:latest\n    restart: unless-stopped\n    extra_hosts:\n      - host.docker.internal:host-gateway\n    networks:\n      default:\n      tunnel_external:\n        aliases:\n          - traefik\n      proxy_external:\n        aliases:\n          - traefik\n    ports:\n      - 80:8000\n      - 443:8020\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n      - ./traefik.yml:/etc/traefik/traefik.yaml\n      - ./letsencrypt:/letsencrypt\n    environment:\n      TZ: America/Guayaquil\n      CF_DNS_API_TOKEN: ${CLOUDFLARE_API_TOKEN}\n    labels:\n      traefik.enable: true\n      traefik.docker.network: proxy_external\n      traefik.http.routers.traefik.rule: Host(`${DOMAIN_TRAEFIK}`)\n      traefik.http.routers.traefik.entrypoints: direct\n      traefik.http.routers.traefik.tls: true\n      traefik.http.routers.traefik.tls.certresolver: le\n      traefik.http.routers.traefik.service: traefik@docker\n      traefik.http.services.traefik.loadbalancer.server.port: 8080\n\nnetworks:\n  proxy_external:\n    external: true\n  tunnel_external:\n    external: true\n</code></pre>"},{"location":"servers/misc-us-east-1/services/networking/traefik/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>CLOUDFLARE_API_TOKEN=\nDOMAIN_TRAEFIK=\n</code></pre>"},{"location":"servers/misc-us-east-1/services/networking/traefik/#reverse-proxy","title":"Reverse Proxy","text":"<p>Traefik usually comes with a web dashboard for managing the resources exposed. Now, we're actually using it to expose its dashboard itself.</p> <p>For this reason, you will see that this service has:</p> <ol> <li>A number of labels with names starting with <code>traefik</code>.</li> </ol> <p>If you don't want to use the proxy itself to expose its own dashboard, feel free to remove those labels and bind the dashboard port manually.</p>"},{"location":"servers/misc-us-east-1/services/networking/traefik/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/misc-us-east-1/services/networking/traefik/#further-reading","title":"Further Reading","text":"<p>This page just described the basic steps to follow to set up the reverse proxy. This is far from done, make sure you check out:</p> <ul> <li>How to expose web services via Cloudflare with cloudflared.</li> </ul>"},{"location":"servers/nano-ec-uio-1/configuration/","title":"Introduction","text":"<p>This section contains details of the <code>nano-ec-uio-1</code> server.</p> <p>This server is mostly used for very specific low performance purposes.</p>"},{"location":"servers/nano-ec-uio-1/configuration/#server-specs","title":"Server Specs","text":"<p>This server is a Raspberry Pi 3B with the following specs:</p> <ul> <li>OS: Raspbian (bookworm) Lite</li> <li>CPU: Raspberry Pi 3B 4x@1.2GHz</li> <li>RAM: 1GB</li> <li>Storage:<ol> <li>64GB SD Card</li> </ol> </li> </ul>"},{"location":"servers/nano-ec-uio-1/configuration/docker/","title":"Docker","text":"<p>Some services in the server will be run through Docker. We'll need to install it first.</p>"},{"location":"servers/nano-ec-uio-1/configuration/docker/#installation","title":"Installation","text":"<p>To install Docker, simply run the following commands:</p> <pre><code>curl -fsSL https://get.docker.com -o get-docker.sh\nsudo sh ./get-docker.sh\n</code></pre> <p>Once it's done, you can remove the downloaded script:</p> <pre><code>rm get-docker.sh\n</code></pre>"},{"location":"servers/nano-ec-uio-1/configuration/docker/#permissions","title":"Permissions","text":"<p>We'll add the required permissions for our user into the <code>docker</code> group.</p> <pre><code>sudo groupadd docker\nsudo gpasswd -a $USER docker\n</code></pre>"},{"location":"servers/nano-ec-uio-1/configuration/installation/","title":"Installation","text":"<p>Flash your SD Card with the OS of your choice, in this case, we'll be using Raspberry Pi OS Lite. Head over to the Operating Systems page for more information. You can choose Raspberry Pi OS Desktop, however the Lite version will contain much less clutter that will be unnecessary.</p>"},{"location":"servers/nano-ec-uio-1/configuration/installation/#post-installation","title":"Post-Installation","text":"<p>As a general rule of thumb, after installing the OS it is recommended to update the sources and packages:</p> <pre><code>sudo apt-get update &amp;&amp; sudo apt-get upgrade\n</code></pre>"},{"location":"servers/nano-ec-uio-1/configuration/installation/#configuring","title":"Configuring","text":"<p>Before continuing we must change some system information using the <code>raspi-config</code> utility.</p> <p>Note</p> <p>You will need to reboot your device after completing all these changes in order for them to have effect.</p>"},{"location":"servers/nano-ec-uio-1/configuration/installation/#change-the-hostname","title":"Change the Hostname","text":"<p>The hostname is the name of the machine, by default it is set to <code>pi</code> which might not be descriptive enough. In order to change it, open the configurator utility:</p> <pre><code>sudo raspi-config\n</code></pre> <p>And choose the following options:</p> <pre><code>System Options &gt; Hostname\n</code></pre> <p>And insert the hostname you wish to use.</p>"},{"location":"servers/nano-ec-uio-1/configuration/installation/#disable-screen-blanking","title":"Disable Screen Blanking","text":"<p>Since this will be an always-on monitoring dashboard, we must disable the screen from turning off. Inside the <code>raspi-config</code> utility, select the options:</p> <pre><code>Display Options &gt; Screen Blanking\n</code></pre> <p>And disable it.</p>"},{"location":"servers/nano-ec-uio-1/configuration/installation/#change-the-timezone","title":"Change the Timezone","text":"<p>Your Raspberry Pi might have the incorrect timezone set, it is very important to have the correct time in your device to avoid problems with connectivity. Inside the <code>raspi-config</code> utility, select the options:</p> <pre><code>Localisation Options &gt; Timezone\n</code></pre> <p>And pick your own timezone.</p>"},{"location":"servers/nano-ec-uio-1/configuration/installation/#connect-to-wi-fi","title":"Connect to Wi-Fi","text":"<p>In the case that using Ethernet is not possible, Wi-Fi will be necessary. Since we do not have a GUI yet, we need to connect to the Internet through the <code>raspi-config</code>. Inside the utility, select the options:</p> <pre><code>System Options &gt; Wireless LAN\n</code></pre> <p>Insert your Wi-Fi's SSID and password to connect.</p>"},{"location":"servers/nano-ec-uio-1/configuration/installation/#enable-ssh","title":"Enable SSH","text":"<p>Remote control will be necessary to avoid having to use the machine directly. For this, SSH should be enabled. In the same <code>raspi-config</code> utility, select the options:</p> <pre><code>Interface Options &gt; SSH &gt; Enable\n</code></pre> <p>SSH should now be enabled.</p>"},{"location":"servers/nano-ec-uio-1/configuration/installation/#enable-autologin","title":"Enable Autologin","text":"<p>We need this machine to automatically log with the admin user, for this choose the following options:</p> <pre><code>System Options &gt; Auto Login &gt; Enable\n</code></pre> <p>The user will be automatically logged in on system startup.</p>"},{"location":"servers/nano-ec-uio-1/configuration/installation/#packages","title":"Packages","text":"<p>Here's a list of packages I like to have on the server.</p> <pre><code>sudo apt-get install tmux xterm git neofetch\n</code></pre>"},{"location":"servers/nano-ec-uio-1/configuration/installation/#installing-gotop","title":"Installing <code>gotop</code>","text":"<p><code>gotop</code> is a pretty performance monitor that display a nice UI on the terminal. To install this, run the following commands:</p> <pre><code>git clone --depth 1 https://github.com/cjbassi/gotop /tmp/gotop\n/tmp/gotop/scripts/download.sh\nsudo mv gotop /usr/local/bin\n</code></pre>"},{"location":"servers/nano-ec-uio-1/configuration/installation/#generate-ssh-key","title":"Generate SSH Key","text":"<p>This server in particular will SSH to other machines to monitor them with <code>gotop</code>. For this we'll create an SSH key with the following command:</p> <pre><code>ssh-keygen -t ed25519 -C \"your_email@example.com\"\n</code></pre> <p>Then, copy the contents of the <code>~/.ssh/ed25519.pub</code> file into the destination server's <code>~/.ssh/authorized_keys</code> file.</p>"},{"location":"servers/nano-ec-uio-1/configuration/installation/#installing-a-wm","title":"Installing a WM","text":"<p>For this server we will need a GUI. We'll install a simple WM to avoid overwhelming the Raspberry Pi with heavy usage that might hinder our experience. For this, we'll use Awesome WM.</p> <p>First, install X and Awesome:</p> <pre><code>sudo apt-get install xinit awesome \n</code></pre> <p>And start it,</p> <pre><code>startx\n</code></pre> <p>We'll install a theme to the WM so it does not look too bare-bones. We'll use awesome-copycats for this. Install this with:</p> <pre><code>git clone --recurse-submodules --remote-submodules --depth 1 -j 2 https://github.com/lcpz/awesome-copycats.git\nmkdir -p ~/.config/awesome\nmv -bv awesome-copycats/{*,.[^.]*} ~/.config/awesome; rm -rf awesome-copycats\ncd ~/.config/awesome\ncp rc.lua.template rc.lua\n</code></pre> <p>Finally, restart awesome by right-clicking anywhere on the desktop and selecting the Restart option.</p> <p>In order for the Raspberry Pi to automatically open Awesome on system boot, edit the following file:</p> <pre><code>sudo nano /etc/profile\n</code></pre> <p>And add the following lines:</p> <pre><code>if [[ ! $DISPLAY &amp;&amp; $XDG_VTNR -eq 1 ]]; then\n  exec startx\nfi\n</code></pre>"},{"location":"servers/nano-ec-uio-1/configuration/installation/#customizing-terminal","title":"Customizing Terminal","text":"<p>Create a <code>.Xresources</code> file with:</p> <pre><code>nano ~/.Xresources\n</code></pre> <p>And paste the following content:</p> <pre><code>*foreground:   #c5c8c6\n*background:   #1d1f21\n*cursorColor:  #aeafad\n*color0:       #000000\n*color1:       #912226\n*color2:       #778900\n*color3:       #ae7b00\n*color4:       #1d2594\n*color5:       #682a9b\n*color6:       #2b6651\n*color7:       #929593\n*color8:       #666666\n*color9:       #cc6666\n*color10:      #b5bd68\n*color11:      #f0c674\n*color12:      #81a2be\n*color13:      #b294bb\n*color14:      #8abeb7\n*color15:      #ecebec\n</code></pre> <p>Now the terminal should have pretty colors.</p>"},{"location":"servers/nano-ec-uio-1/configuration/installation/#firewall","title":"Firewall","text":"<p>UFW is a friendly frontend for iptables that makes it a lot easier to add connection rules to your firewall.</p> <p>We'll need to install UFW and set it up.</p> <pre><code>sudo apt-get install ufw\nsudo ufw default allow outgoing\nsudo ufw default deny incoming\nsudo ufw allow ssh\nsudo ufw enable\n</code></pre> <p>The commands should be pretty self-explanatory, these default the firewall to allow any connections going from the server to the Internet and deny any incoming connections from the Internet to the server.</p> <p>Make sure to also enable the <code>ssh</code> ports, otherwise you may get locked out of your system remotely and may need to physically configure the firewall to allow SSH connections.</p>"},{"location":"servers/nano-ec-uio-1/configuration/monitor/","title":"Monitor","text":"<p>This server's main use is to monitor the rest of the servers with <code>gotop</code>. I've made a nice script that launches all the <code>gotop</code> instances through SSH on all the services and presents them on a nice <code>tmux</code> session.</p>"},{"location":"servers/nano-ec-uio-1/configuration/monitor/#script","title":"Script","text":"<p>Create the monitor script file:</p> <pre><code>mkdir monitor\nnano monitor/gotop.sh\n</code></pre> <p>The script content is as follows:</p> <pre><code>#!/bin/bash\n\nSESSION=monitor\n\ntmux new-session -d -s $SESSION\n\ntmux set-option -t $SESSION pane-border-status top\ntmux set-option -t $SESSION pane-border-format \"#{pane_title}\"\ntmux set-option -t $SESSION pane-border-style fg=green\ntmux set-option -t $SESSION pane-active-border-style fg=green\n\ntmux split-window -h -t ${SESSION}.0\ntmux split-window -h -t ${SESSION}.1\ntmux select-layout -t \"$SESSION\" even-horizontal\n\nTOP_PANES=$(tmux list-panes -t $SESSION -F \"#{pane_id}\" | tr '\\n' ' ')\n\nfor PID in $TOP_PANES; do\n  tmux split-window -v -t $PID\ndone\n\nALL_PANES=$(tmux list-panes -t $SESSION -F \"#{pane_id}\" | tr '\\n' ' ')\n\nTITLES=(\n  \"misc-ec-uio-1\"\n  \"dev-ec-uio-1\"\n  \"nano-ec-uio-1\"\n  \"misc-us-east-1\"\n  \"deploy-us-east-1\"\n  \"dev-eu-west-1\"\n)\n\nCOMMANDS=(\n  \"ssh user@server.com -t 'gotop'\"\n  \"ssh user@server.com -t 'gotop'\"\n  \"gotop\"\n  \"ssh user@server.com -t 'gotop'\"\n  \"ssh user@server.com -t 'gotop'\"\n  \"ssh user@server.com -t 'gotop'\"\n)\n\nfor PID in $ALL_PANES; do\n  i=${PID#%}\n  title=${TITLES[$i]}\n  cmd=${COMMANDS[$i]}\n\n  tmux select-pane -T $title -t $PID\n  tmux send-keys -t $PID \"$cmd\" C-m \ndone\n\ntmux attach-session -t $SESSION\n</code></pre>"},{"location":"servers/nano-ec-uio-1/configuration/monitor/#auto-starting","title":"Auto-starting","text":"<p>The idea is this script runs as soon as the Raspberry Pi turns on. For this, we'll edit the <code>~/.xinitrc</code> file and add the following content:</p> <pre><code>awesome &amp; sleep 15 &amp;&amp; xrdb ~/.Xresources &amp;&amp; xterm -fullscreen -e \"(cd ~/monitor &amp;&amp; ./gotop.sh)\"\n</code></pre> <p>This starts the Awesome WM, waits until it's up, loads up the terminal colors and then starts <code>xterm</code> in fullscreen mode with the script.</p>"},{"location":"servers/nano-ec-uio-1/services/management/","title":"Initialization","text":"<p>All the services inside this section will be run through Docker. Since we'll use Docker Compose to execute the services, we'll create a folder on the main user's home folder dedicated to management services.</p> <pre><code>mkdir ~/services/management\n</code></pre> <p>For each service created, there will be a subfolder where a <code>docker-compose.yml</code> file will be located, alongside any data volumes required and even a <code>Dockerfile</code> if required.</p>"},{"location":"servers/nano-ec-uio-1/services/management/portainer-agent/","title":"Portainer Agent","text":"<p>Portainer is a web UI for Docker which allows us to have an insight on all the containers running on our server.</p> <p>The Portainer agent allows you to expose the machine's Docker management to another Portainer service hosted elsewhere. We're using the agent in this case to use the main Portainer service to manage this one.</p> <p>There is an official image for this service that we'll use: portainer/agent.</p>"},{"location":"servers/nano-ec-uio-1/services/management/portainer-agent/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/management/portainer-agent\n</code></pre>"},{"location":"servers/nano-ec-uio-1/services/management/portainer-agent/#docker-compose","title":"Docker Compose","text":"<p>Portainer Agent will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  agent:\n    image: portainer/agent:latest\n    restart: unless-stopped\n    ports:\n      - 9001:9001\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - /var/lib/docker/volumes:/var/lib/docker/volumes\n    environment:\n      TZ: America/Guayaquil\n</code></pre>"},{"location":"servers/nano-ec-uio-1/services/management/portainer-agent/#add-to-portainer","title":"Add to Portainer","text":"<p>In your main Portainer service,</p> <ol> <li>Head over to <code>Environments &gt; Add environment</code>.</li> <li>Pick <code>Docker Standalone</code> and click on <code>Start wizard</code>.</li> <li>Select <code>Agent</code>, set a <code>Name</code> for your agent and paste your server's address with <code>9001</code> as the port into <code>Environment address</code>.</li> <li>Finally, click <code>Connect</code>.</li> </ol> <p>And that's it, you can now manage your server's Docker services from your main Portainer service.</p>"},{"location":"servers/nano-ec-uio-1/services/management/portainer-agent/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"},{"location":"servers/nano-ec-uio-1/services/networking/","title":"Initialization","text":"<p>All the services inside this section will be run through Docker. Since we'll use Docker Compose to execute the services, we'll create a folder on the main user's home folder dedicated to networking services.</p> <pre><code>mkdir ~/services/networking\n</code></pre> <p>For each service created, there will be a subfolder where a <code>docker-compose.yml</code> file will be located, alongside any data volumes required and even a <code>Dockerfile</code> if required.</p>"},{"location":"servers/nano-ec-uio-1/services/networking/tailscale/","title":"Tailscale","text":"<p>Tailscale is a virtual LAN service, similar to Hamachi, that allows you to have your services exposed through a VPN.</p> <p>There is an official image for this service that we'll use: tailscale/tailscale.</p>"},{"location":"servers/nano-ec-uio-1/services/networking/tailscale/#pre-installation","title":"Pre-Installation","text":"<p>We'll create a folder in the main user's home where all the service's data will be saved.</p> <pre><code>mkdir ~/services/networking/tailscale\n</code></pre>"},{"location":"servers/nano-ec-uio-1/services/networking/tailscale/#getting-an-auth-key","title":"Getting an Auth Key","text":"<p>First head over to your Tailscale account's Dashboard &gt; Settings &gt; Keys and create <code>Generate auth key...</code>. You can name this key whatever you want and set the expiry to 1 day since we'll use it right off the bat.</p> <p>Once you generate it, copy it and save it somewhere, we'll use it in the docker-compose.yml file.</p>"},{"location":"servers/nano-ec-uio-1/services/networking/tailscale/#docker-compose","title":"Docker Compose","text":"<p>Tailscale will be run using Docker Compose. The content of the <code>docker-compose.yml</code> file is as follows:</p> <pre><code>services:\n  vpn:\n    image: tailscale/tailscale:latest\n    restart: unless-stopped\n    network_mode: host\n    cap_add:\n      - NET_ADMIN\n      - SYS_MODULE\n    volumes:\n      - /dev/net/tun:/dev/net/tun\n      - ./data:/var/lib/tailscale\n    environment:\n      TZ: America/Guayaquil\n      TS_AUTHKEY: ${TAILSCALE_AUTH_KEY}\n      TS_EXTRA_ARGS: --advertise-tags=tag:container --advertise-exit-node --accept-routes\n      TS_STATE_DIR: /var/lib/tailscale\n      TS_USERSPACE: false\n</code></pre>"},{"location":"servers/nano-ec-uio-1/services/networking/tailscale/#secrets","title":"Secrets","text":"<p>Make sure to create a <code>.env</code> file with the following structure:</p> <pre><code>TAILSCALE_AUTH_KEY=\n</code></pre>"},{"location":"servers/nano-ec-uio-1/services/networking/tailscale/#running","title":"Running","text":"<p>Start up the service with:</p> <pre><code>docker compose up -d\n</code></pre> <p>That's it! The service will auto-start on system startup and restart on failure.</p>"}]}